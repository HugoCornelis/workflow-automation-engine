#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
#

use strict;


my $loaded_mail_sender = eval "require Mail::Sender";

use Data::Transformator;

use Expect;

use Getopt::Long;

use Neurospaces::Tester;;

use YAML;


my $option_check_test_names;
our $option_debugging;
my $option_dump_json;
my $option_dump_perl;
my $option_dump_yaml;
my $option_email = defined $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} ? $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} : 0 ;
my $option_flattenout;
my $option_help;
my $option_numerical_compare;
my $option_output;
my $option_output_content_line_limit = 10;
my $option_output_figures;
my $option_output_html;
my $option_output_latex;
my $option_output_levels = [];
my $option_output_pdf;
my $option_random_order;
my $option_regex_selector = ".*";
my $option_report_disabled;
my $option_show;
my $option_show_command_tests;
my $option_tags = [];
my $option_timeout_multiplier = 1;
my $option_timings;
my $option_trace;
my $option_verbose;


our $global_config;

my $global_all_output_levels
    = [
       "meta",
       "module",
       "command_definition",
       "command_test",
      ];

my $global_error_count = 0;
my $global_fd_output;
my $global_previous_command_side_effects;
my $global_test_report;


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $global_test_report->{global}->{status} = 'Died';

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $global_test_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub initialize_config_environment
{
    my $fd_initialization;

    open($fd_initialization, ">&STDOUT");

    my $environment_settings = $global_config->{environment_settings};

    foreach my $environment_setting_name (keys %$environment_settings)
    {
	my $environment_setting = $environment_settings->{$environment_setting_name};

	# if simply setting values in the environment

	if (!ref $environment_setting)
	{
	    # set the value in the environment

	    $ENV{$environment_setting_name} = $environment_setting;
	}

	# if additional initialization required

	elsif (ref $environment_setting eq 'HASH')
	{
	    # get environment_setting value

	    my $value = $environment_setting->{value};

	    # set the value in the environment

	    $ENV{$environment_setting_name} = $value;

	    # give feedback

	    my $description = $environment_setting->{description};

	    $description =~ s/%value/$value/g;

	    if ($option_verbose)
	    {
		print $fd_initialization $description;
	    }

	    # loop over shell commands for initialization

	    my $shell_commands = $environment_setting->{initialization}->{shell};

	    foreach my $shell_command (@$shell_commands)
	    {
		# replace value

		$shell_command =~ s/%value/$value/g;

		# execute command

		if ($option_verbose)
		{
		    print $fd_initialization "$0: Executing ($shell_command)\n";
		}

		system $shell_command;
	    }
	}
	else
	{
	    die "$0: illegal environment_settings, was processing $environment_setting";
	}
    }
}


sub initialize_globals
{
    $global_test_report
	= {
	   %$global_test_report,
	   description => {
			   command => $0,
			   name => "Test report",
			   package => $global_config->{package},
			  },
	   global => {
		      config => $global_config,
		      error_count => $global_error_count,
		      status => 'initializing',
		      test_counters => {
					module_definition => 0,
					command_definition => 0,
					command_test => 0,
				       },
		      time_start => `date`,
		     },
	   target => {
		      OS => $^O,
		      system => {
				 libc => (join '', `(ls -l /lib/libc-* && ls -l /usr/lib/libc-*) 2>/dev/null`),
				 uname => (join '', `uname -a`),
				 cpu => (join '', `cat /proc/cpuinfo`),
				},
		      packages => {
				   '/etc/lsb-release' => (join '', `cat /etc/lsb-release`),
				   autoconf => (join '', `autoconf --version`),
				   automake => (join '', `automake --version`),
				   bison => (join '', `bison --version`),
				   flex => (join '', `flex --version`),
				   gcc => (join '', `gcc 2>&1 --version && gcc 2>&1 -v`),
				   perl => (join '', `perl 2>&1 -v && perl 2>&1 -V`),
				   python => (join '', `python 2>&1 --version`),
				   python_installation => (join '', `./contrib/pythontest 2>&1`),
				   swig => (join '', `swig 2>&1 -version`),
				  },
		     },
	  };
}


sub initialize_config
{
    # find the package core directory

    $global_config = do './tests.config';

    if (!defined $global_config)
    {
	die "No test configuration found";
    }

    # add to tests directory to include paths

    if (!exists $global_config->{tests_directory})
    {
	$global_config->{tests_directory} = "./tests/specifications";

	$global_config->{introduction_filename} = "tests/introduction.html";
    }

    unshift @INC, $global_config->{tests_directory};
}


sub main
{
    parse_options();

    initialize_config();

    initialize_config_environment();

    initialize_globals();

    open($global_fd_output, ">&STDOUT");

    # find all the test module files

    my $test_module_references = Heterarch::Test::Library::construct();

    # read the test module files

    my $test_module_library_contents = Heterarch::Test::Library::expand($global_fd_output, $test_module_references);

    my $test_modules = $test_module_library_contents->{test_modules};

    # compute the model library checksum

    my $library_sha_before;

    if (defined ($global_config->{model_library}))
    {
	$library_sha_before = ModelLibrary::sha();
    }

    # the previous command had no side effects on the loaded model (since there is no model yet)

    $global_previous_command_side_effects = 0;

    # set status: running

    $global_test_report->{global}->{status} = 'Running';

    # randomize test module order if requested

    if (defined $option_random_order)
    {
	if ($option_verbose)
	{
	    print $global_fd_output "$0: Randomizing test specifications, random seed is $option_random_order\n";
	}

	# by default the randomizer will choose a random_seed

	my $random_seed;

	if ($option_random_order =~ /^[0-9]*$/
	    and $option_random_order ne 1)
	{
	    $random_seed = $option_random_order
	}

	# randomize the test module library

	( $test_modules, $random_seed ) = Heterarch::Test::Library::randomize_order($test_modules, $random_seed);

	$global_test_report->{random_seed} = $random_seed;
    }
    else
    {
	$global_test_report->{random_seed} = 'not randomized';
    }

    $global_test_report->{global}->{test_counters}
	= {
	   module_definition => 0,
	   command_definition => 0,
	   command_test => 0,
	  };

    # create an execution context for running the tests

    my $execution_context = Heterarch::Test::ExecutionContext->new($global_fd_output, { library_sha_before => $library_sha_before, }, );

    # create a test executor for running the tests following the requested type of output

    my $executor = $option_output->new($execution_context);

    # loop over all module definitions

    foreach my $module_definition (@$test_modules)
    {
	bless $module_definition, "Heterarch::Test::Module";

	my $fd_module_output = $global_fd_output;

	my $error = $module_definition->md_run($execution_context, $executor, $fd_module_output);
    }

    $global_test_report->{global}->{time_end} = `date`;

    # do final processing of the executor

    $executor->ex_terminate($global_fd_output, $test_module_library_contents);

    # end the execution_context

    $execution_context->ec_terminate();

    # close pending commands

    Heterarch::Test::CommandDefinition::Interactive::close_pending();

    # close the test report

    $global_test_report->{global}->{status} = 'Finished';

    # final report

    report_exit(0, $test_module_library_contents);
}


sub parse_options
{
    $option_numerical_compare = $global_config->{numerical_compare} || 0;

    my $result
	= GetOptions
	    (
	     "check-test-names!" => \$option_check_test_names,
	     "debugging=s" => \$option_debugging,
	     "dump-json!" => \$option_dump_json,
	     "dump-perl!" => \$option_dump_perl,
	     "dump-yaml!" => \$option_dump_yaml,
	     "email" => \$option_email,
	     "flattenout" => \$option_flattenout,
	     "help!" => \$option_help,
	     "numerical-compare!" => \$option_numerical_compare,
	     "output=s" => \$option_output,
	     "output-content-line-limit=s" => \$option_output_content_line_limit,
	     "output-figures" => \$option_output_figures,
	     "output-html" => \$option_output_html,
	     "output-latex" => \$option_output_latex,
	     "output-levels=s" => $option_output_levels,
	     "output-pdf" => \$option_output_pdf,
	     "randomize-order=s" => \$option_random_order,
	     "regex-selector=s" => \$option_regex_selector,
	     "report-disabled!" => \$option_report_disabled,
	     "show!" => \$option_show,
	     "show-command-tests!" => \$option_show_command_tests,
	     "tags=s" => $option_tags,
	     "timeout-multiplier=s" => \$option_timeout_multiplier,
	     "timings!" => \$option_timings,
	     "trace!" => \$option_trace,
	     "v|verbose+" => \$option_verbose,
	    );

    if (!$result)
    {
	die "$0: Error in option processing";
    }

    if (not defined $option_output)
    {
	if ($option_output_html)
	{
	    $global_test_report->{output_format} = 'yaml_exit';

	    $option_output = "Heterarch::Test::Output::Formatter::HTMLTable";
	}
	elsif ($option_output_latex)
	{
	    $global_test_report->{output_format} = 'latex';

	    $option_output = "Heterarch::Test::Output::Formatter::Latex";
	}
	elsif ($option_output_pdf)
	{
	    $global_test_report->{output_format} = 'pdf';

	    $option_output = "Heterarch::Test::Output::Formatter::PDF";
	}
	elsif ($option_show)
	{
	    $global_test_report->{output_format} = 'yaml_exit';

	    $option_output = "Heterarch::Test::Output::Formatter::YAML::Summary";
	}
	elsif ($option_show_command_tests)
	{
	    $global_test_report->{output_format} = 'yaml_exit';

	    $option_output = "Heterarch::Test::Output::Formatter::YAML::CommandTests";
	}
	else
	{
	    $global_test_report->{output_format} = 'executor';

	    $option_output = "Heterarch::Test::Executor";
	}
    }

    if (not scalar @$option_output_levels)
    {
	use Clone 'clone';

	$option_output_levels = clone($global_all_output_levels);
    }

    $global_test_report->{options}
	= {
	   check_test_names => $option_check_test_names,
	   debugging => $option_debugging,
	   dump_json => $option_dump_json,
	   dump_perl => $option_dump_perl,
	   dump_yaml => $option_dump_yaml,
	   email => $option_email,
	   flattenout => $option_flattenout,
	   help => $option_help,
	   numerical_compare => $option_numerical_compare,
	   output => $option_output,
	   output_figures => $option_output_figures,
	   output_html => $option_output_html,
	   output_latex => $option_output_latex,
	   output_levels => $option_output_levels,
	   output_pdf => $option_output_pdf,
	   random_order => $option_random_order,
	   regex_selector => $option_regex_selector,
	   report_disabled => $option_report_disabled,
	   show => $option_show,
	   show_command_tests => $option_show_command_tests,
	   tags => $option_tags,
	   timeout_multiplier => $option_timeout_multiplier,
	   timings => $option_timings,
	   trace => $option_trace,
	   verbose => $option_verbose,
	  };

    if ($option_help)
    {
	print
	    "
$0: test definition executor

options:
    --check-test-names           check the pathnames of the specification files against the names of the tests.
    --debugging                  enable specific debugging options.
    --dump-json                  dump test specifications to json files in /tmp/.
    --dump-perl                  dump test specifications to perl files in /tmp/.
    --dump-yaml                  dump test specifications to yaml files in /tmp/.
    --email                      allow to send emails, the default is taken from \$ENV{NEUROSPACES_HARNESS_OPTION_EMAIL}.
    --flattenout                 flattenout the test definitions before testing,
                                 this experimental feature might increase test performance,
                                 by recycling test definitions.
    --help                       print usage information.
    --numerical-compare          attempt to compare numbers numerically when string differences are found (default enabled).
    --output                     the class that should generate the output (default is '$option_output').
    --output-content-line-limit  maximum number of lines when generating content output (latex, html, pdf).
    --output-figures             generate figures for test output with a figure clause.
    --output-html                generate HTML output.
    --output-latex               generate Latex output.
    --output-levels              generate output for these levels (default is '" . ( join ', ', @$global_all_output_levels ) . "'.
    --output-pdf                 generate PDF output.
    --randomize-order            randomize the order of the tests before executing them (require List::Util to be installed).
    --regex-selector             defines a regex to run specific tests.
    --report-disabled            include information of disabled tests in the test report.
    --show                       show tests that would be run using the current configuration.
    --show-command-tests         show all the command definitions that would be run during test execution, including the input to those commands.
    --tags                       only test test modules that have been tagged with these tags (default: all tags).
    --timeout-multiplier         multiply all timeout values with this constant.
    --timings                    add timing information about the tests to the report.
    --trace                      enable tracing using the strace unix shell command.
    --verbose                    set verbosity level.
";

	exit 1;
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    if (defined $description
        && $exit_code eq 3)
    {
	print STDERR "*** die: $description\n";
    }

    # write the full report to a file

    my $report_filename = ">/tmp/report_$global_config->{package}->{name}.yml";

    eval
    {
	YAML::DumpFile($report_filename, $global_test_report);
    };

    if ($@)
    {
	print STDERR "*** Error: Failed to write output report to $report_filename\n";
    }
    else
    {
	print $global_fd_output "*** Info: See '$report_filename' for the detailed report\n";
    }

    # if email enabled by the options

    if ($option_email)
    {
	# check for a default route

	#! from perl/basic.t

	my $no_default_route = (`/sbin/route` =~ /default/ ? '' : 'no default route to the internet found');

	if (!$no_default_route)
	{
	    # ask if sending an email is ok

	    my $default_answer_prompt = $global_error_count ? "Y/n" : "y/N";

	    print $global_fd_output "\n---\n  These tests generated $global_error_count error(s)";
	    print $global_fd_output ( $global_error_count ? "  Because errors were found, you should really consider sending an email to inform the developer of this software package\n" : "" );
	    print $global_fd_output "\n  Ok to send an email to hugo.cornelis\@gmail.com for this test report,\n  this email will not reveal your identity to the recipient ?  [$default_answer_prompt]";

	    my $answer = readline(*STDIN);

	    # send an email if ok

	    if ($answer =~ /^y/)
	    {
		#t perhaps should consider Mail::Builder, don't know

		if ($loaded_mail_sender)
		{
		    my $sender
			= Mail::Sender->new
			    (
			     {
# 			      smtp => 'googlemail.l.google.com',
			      smtp => 'mta1.uthscsa.edu',
			      from => 'hugo.cornelis@gmail.com',
			     },
			    );

		    print $global_fd_output "Sending ... should not take more than 30 seconds
";

		    my $message
			= (
			   "neurospaces_harness test report\n"
			   . "Generated on " . `date` . "\n"
			   . "\n========\n"
			   . Dump($global_test_report)
			   . "\n========\n"
			  );

		    $sender->MailMsg
			(
			 {
			  to => 'cornelis@uthscsa.edu',
			  subject => '[neurospaces_harness] test report',
			  msg => $message,
			 },
			);

		    # 	    $sender->Attach
		    # 		(
		    # 		 {
		    # 		  description => 'global_test_report',
		    # 		 },
		    # 		);

		    $sender->Close();

		    if ($sender->{error})
		    {
			print STDERR
			    "*** Error: $sender->{error}
Email was not sent.
";
		    }
		    else
		    {
			print $global_fd_output
			    "Email was sent.
";
		    }
		}
		else
		{
		    print STDERR
			"*** Error: Cannot load the perl module Mail::Sender, contact your sysadmin to install this perl module.
(use the shell command \"sudo perl -MCPAN -e 'install Mail::Sender'\")
Email was not sent.
";
		}
	    }
	    else
	    {
		print $global_fd_output
		    "Email was not sent.
";
	    }
	}
	else
	{
	    print STDERR "*** Warning: No default route to the internet found.
Email was not sent.
";
	}
    }
    else
    {
	print $global_fd_output "No email sent.
";
    }

    # if there were errors

    if ($global_error_count)
    {
	# exit with failure

	$exit_code ||= 1;

	print $global_fd_output "$0: $global_test_report->{global}->{test_counters}->{command_test} test(s), $global_error_count error(s)\n";

	print $global_fd_output "$0: exit_code $exit_code\n\n";

	exit $exit_code;
    }

    # else

    else
    {
	# exit, possibly success

	print $global_fd_output "$0: $global_error_count error(s)\n\n";

	exit $exit_code;
    }
}


package ModelLibrary;


sub sha
{
    # find all models

    use File::Find::Rule;

    my $files = [ File::Find::Rule->file()->in( $ENV{NEUROSPACES_NMC_MODELS} ), ];

    my $shas
	= [
	   map
	   {
	       `sha1sum $_`;
	   }
	   @$files,
	  ];

    use Digest::SHA qw(sha1_hex);

    my $sha = sha1_hex(join ', ', @$shas);

    return $sha;
}


package Heterarch::Test::CommandDefinition;


our @ISA = ("Heterarch::Test::Element");


sub process_clauses
{
    my $command_definition = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    if (exists $command_definition->{wait})
    {
	my $wait = $command_definition->{wait};

	$execution_context->wait($fd_output, $wait);
    }
}


sub parse_command_line
{
    my $command_definition = shift;

    my $command_prefix = shift;

    # if we have a command_prefix

    if ($command_prefix
	and scalar @$command_prefix)
    {
	# the command is the first element of the command prefix, the rest are arguments

	my $argument_array = [];

	if (exists $command_definition->{arguments})
	{
	    $argument_array = $command_definition->{arguments};
	}

	my $command_line = $command_definition->{command} . " " . (join ' ', @$argument_array);

	my $command_and_arguments = [ @$command_prefix, $command_line, ];

	my $command = shift @$command_and_arguments;

	return ($command, $command_and_arguments);
    }

    # if we don't have a command prefix

    else
    {
	# the command is the first word, all the rest are arguments

	my $command_array = [];

	if (exists $command_definition->{command})
	{
	    $command_array = [ split '\s', $command_definition->{command}, ];
	}

	my $argument_array = [];

	if (exists $command_definition->{arguments})
	{
	    $argument_array = $command_definition->{arguments};
	}

	my $command_arguments = [ @$command_array, @$argument_array, ];

	my $command = shift @$command_arguments;

	return ($command, $command_arguments);
    }
}


sub rebless
{
    my $command_definition = shift;

    my $target_package = "Heterarch::Test::CommandDefinition";

    # we have to either instantiate an object that produces output ...

    if ($command_definition->{class})
    {
	$target_package = "Heterarch::Test::CommandDefinition::PerlClass";
    }

    # ... or run perl code that produces output

    elsif (ref $command_definition->{command} eq 'CODE')
    {
	$target_package = "Heterarch::Test::CommandDefinition::PerlCode";
    }

    # ... or run a command that produces output

    else
    {
	$target_package = "Heterarch::Test::CommandDefinition::Interactive";
    }

    # rebless

    bless $command_definition, $target_package;

    # return result

    return $command_definition;
}


package Heterarch::Test::CommandDefinition::Interactive;;


our @ISA = ("Heterarch::Test::CommandDefinition");


use Data::Comparator qw(data_comparator);


my $global_exp;

my $global_running_command_definition;


sub close_pending
{
    # if there is a command running

    if ($global_exp)
    {
	# terminate the command

	#t could be that the hard_close() call is needed because
	#t neurospaces uses readline, not sure needs investigation,
	#t perhaps.

	$global_exp->hard_close();
    }
}


sub spawn_new
{
    my $command_definition = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # apply the execution prefix from the harnessing clauses

    my $command_prefix = [];

    my $harness = Heterarch::Test::ExecutionContext::Harness::current();

    if ($harness)
    {
	$command_prefix = $harness->generate_command_prefix($command_definition, $execution_context);
    }

    # retrieve the shell command and its arguments

    my ($command, $arguments) = $command_definition->parse_command_line($command_prefix);

    # compare the running command with this command

    my $new_command_definition
	= {
	    arguments => $arguments,
	    command => $command,
	  };

    my $differences = data_comparator($new_command_definition, $global_running_command_definition);

    # remember to spawn a new command

    my $spawn_new = not $command_definition->{recycle};

    # if the command can be executed

    my $test_startup;

    if (defined $command)
    {
	if ($spawn_new)
	{
	    if ($global_exp)
	    {
		# terminate the previous command

		#t could be that the hard_close() call is needed because
		#t neurospaces uses readline, not sure needs investigation,
		#t perhaps.

		$global_exp->hard_close();
	    }

	    # create a new Expect object by spawning a new process with the new command

	    $global_exp = Expect->new();

	    #! see the expect manual for this one

	    $global_exp->raw_pty(1);

	    # 		    $exp->slave->stty(qw(raw -echo));

	    $global_exp->spawn
		(
		 (
		  $option_trace
		  ? ("strace", "-f")
		  : ()
		 ),
		 $command,
		 @$arguments
		)
		or die "$0: cannot spawn $command: $!\n";

	    # set the running_command_definition

	    $global_running_command_definition = $new_command_definition;

	    print $fd_output "*** Executing $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";

	    # remember to do startup testing

	    $test_startup = 1;

	    # there were no side effects yet

	    $global_previous_command_side_effects = 0;
	}
	else
	{
	    print $fd_output "*** Recycling $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";

	    $test_startup = 0;
	}
    }

    # return the expect object and whether a new command has been started

    return $global_exp, $test_startup;
}


#
# sub start
#
# Starts the application command and connects to its I/O channels.
#

sub cd_start
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    # start the command and connect with its I/O channels

    #! this is similar to having a class clause with value 'Expect' and calling Expect->new()

    my $execution_context = $executor->{execution_context};

    my ($exp, $test_startup) = $self->spawn_new($execution_context, $fd_output);

    $executor->{expect_object} = $exp;

    #! I believe this is obsolete

    $executor->{test_startup} = $test_startup;
}


package Heterarch::Test::CommandDefinition::PerlClass;;


our @ISA = ("Heterarch::Test::CommandDefinition");


#
# sub start
#
# Calls the new method of the given class to instantiate a Perl object.
#

sub cd_start
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    # instantiate the object

    my $class = $self->{class};

    my $filename = $class . ".pm";

    $filename =~ s(::)(/)g;

    require $filename;

    $self->{command_object} = eval "$class->new()";
}


package Heterarch::Test::CommandDefinition::PerlCode;


our @ISA = ("Heterarch::Test::CommandDefinition");


#
# sub start
#
# No-op.
#
# Deprecated: Hardcoded perl code in the test specifications should be removed.
#

sub cd_start
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    # code is already instantiated, nothing to do here

    my $sub = $self->{command};

    # previously, arguments were: self, config.  config has a key
    # $config->{c_code}->{directory} pointing to the directory with
    # the C source code.

    # with the assumption that self has never been used.

    my $error = &$sub();

    if ($error)
    {
	# my $command_definition = $execution_context->get_command_definition();

	# my $current = $self->_get_current();

	# my $module_definition = $current->[0];

	# my $command_definition = $current->[1];

	# my $command_test = $current->[2];

	my $execution_context = $executor->{execution_context};

	my $module_definition = $execution_context->get_module_definition();

	my $module_name = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => "command_definition $self->{description}",
		  error => $error,
		  module_name => $module_name,
		 },
		);
    }

    return $error;
}


package Heterarch::Test::CommandDefinition::IsFileExecutable;


our @ISA = ("Heterarch::Test::CommandDefinition");


#
# sub start
#

sub cd_start
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    # code is already instantiated, nothing to do here

    my $sub = $self->{command};

    my $error;

    if (-x "workflow-tests-commands-data/examples_sh/sh_single_command.sh")
    {
    }
    else
    {
	$error = "workflow-tests-commands-data/examples_sh/sh_single_command.sh does not have its execute bit set"
    }

    if ($error)
    {
	# my $command_definition = $execution_context->get_command_definition();

	# my $current = $self->_get_current();

	# my $module_definition = $current->[0];

	# my $command_definition = $current->[1];

	# my $command_test = $current->[2];

	my $execution_context = $executor->{execution_context};

	my $module_definition = $execution_context->get_module_definition();

	my $module_name = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => "Heterarch::Test::CommandDefinition::IsFileExecutable $self->{description}",
		  error => $error,
		  module_name => $module_name,
		 },
		);
    }

    return $error;
}


package Heterarch::Test::CommandTest;


our @ISA = ("Heterarch::Test::Element");


#
# _after_run()
#
# 1. records the time it took to execute the test.
# 2. calls approximate testers if this is allowed by options.
#

sub _after_run
{
    my $self = shift;

    my $execution_context = shift;

    my $test_result = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    my $time_start = $self->{time_start};

    my $time_elapsed = tv_interval($time_start);

    # fill in the elapsed time in the report

    if ($option_timings)
    {
	my $module_definition = $self->{module_definition};

	my $module_name = $module_definition->{name};

	my $description = $self->{description};

	$global_test_report->{timings}->{$module_name}->{$description} = $time_elapsed;
    }

    # attempt to correct if the result is almost correct

    #! perl code does not produce a full test result object, so we cannot try to correct an almost correct result

    if (not (ref $command eq 'CODE'))
    {
	# if things don't match

	if ($test_result->{error})
	{
	    my $module_definition = $self->{module_definition};

	    # if allowed to compare numerically

	    if ((!$self->{string_only}
		 && $option_numerical_compare)

		# or forced to compare numerically

		|| $self->{numerical_compare}
		|| $command_definition->{numerical_compare}
		|| $module_definition->{numerical_compare})
	    {
		# compare numerically

		push @{$global_test_report->{numerical_compare}}, $self->{description};

		#! this call uses the $read variable, making it harder to bring this call
		#! outside the condition that tests if this variable is defined
		#! this variable contains the expected output

		$test_result->{error}
		    = Neurospaces::Tester::Comparators::numerical
		        (
			 {
			  description => $self->{description},
			 },
			 $test_result->{before_match},
			 $test_result->{expected},
			 $test_result->{error});
	    }
	}
    }

    # return result

    return $test_result;
}


sub after_testing
{
    my $self = shift;

    my $execution_context = shift;

    my $test_result = shift;

    return $self->_after_run($execution_context, $test_result);
}


sub _before_run
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # record time

    use Time::HiRes qw(gettimeofday tv_interval);

    my $time_start = [ gettimeofday(), ];

    $self->{time_start} = $time_start;
}


#
# sub before_testing()
#
# Calls ->_before_run() to record the current time.
#
# This method is overriden in the Interactive package.
#

sub before_testing
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # record time

    $self->_before_run($execution_context, $fd_output);
}


sub rebless
{
    my $command_test = shift;

    my $target_package = "Heterarch::Test::CommandTest";

    if (ref $command_test->{write} eq 'ARRAY')
    {
	# command_object

	$target_package = "Heterarch::Test::CommandTest::CommandObject";

	my $writes = $command_test->{write};

	foreach my $write (@$writes)
	{
	    my $method = $write->{method};

	    my $arguments = $write->{arguments};
	}

	# compare the read data with what is expected

	if (exists $command_test->{read})
	{
	    my $read = $command_test->{read};
	}
    }

    # if the command_definition has executable perl code

    # elsif (ref $command eq 'CODE')
    # {
	# $target_package = "Heterarch::Test::CommandTest::PerlCode";

    # }

    # else the command definition runs a shell command

    else
    {
	# set read, wait and write strings

	$target_package = "Heterarch::Test::CommandTest::Interactive";

	my $read = $command_test->{read};

	my $wait = $command_test->{wait};

	my $write = $command_test->{write};

	# set timeout, defaults to two seconds, but for newly created processes add two additional seconds.

	my $timeout
	    = (defined $command_test->{timeout}
	       ? $command_test->{timeout} * $option_timeout_multiplier
	       : (0
		  ? 4 * $option_timeout_multiplier
		  : 2 * $option_timeout_multiplier));

	# write

	if (ref $write eq 'HASH')
	{
	}
	elsif (defined $write)
	{
	    # send write to the command under test via the expect object
	}

	# wait

	if ($wait)
	{
	    # wait for $wait seconds
	}

	# check the shell command that will be executed with a timeout

	my $shell = $command_test->{shell};

	if (ref $shell eq 'HASH')
	{
	    #! not sure what this can be
	}
	elsif (defined $shell)
	{
	    # run the command for a maximum of $timeout seconds

	    # fall through
	}

	# if there is an external application to test the final output

	#! the previous shell command was a post-processor, this one is a tester

	my $tester = $command_test->{tester};

	if ($tester)
	{
	    $target_package = "Heterarch::Test::CommandTest::Interactive::ShellTester";

	    # set the external tester that compares the generated output with what is expected

	    #! the external tester runs an executable shell command

	    my $shell = $tester->{shell};

	    # there must be a shell command we should run

	    if ($shell)
	    {
		my $produced = `$shell`;

		my $test_result
		    = {
		       expected => defined $tester->{expected} ? $tester->{expected} : '',
		      };

		if (($produced eq ''
		     and $test_result->{expected} ne '')
		    or ($produced ne ''
			and $test_result->{expected} eq ''))
		{
		    $test_result->{error} = "external tester produces output that is different from what is expected, one is empty, the other is not";

		    $test_result->{before_match} = $produced;
		}
		elsif ($produced =~ /$test_result->{expected}/)
		{
		}
		else
		{
		    $test_result->{error} = "the external tester produces output that is different from the expected output";

		    $test_result->{before_match} = $produced;
		}
	    }
	    else
	    {
		die "$0: *** Error: external testers must have a shell command";
	    }
	}

	# read

	elsif (defined $read)
	{
	    # if literal text expected

	    if (!ref $read)
	    {
		if (exists $command_test->{white_space})
		{
		    if ($command_test->{white_space} eq 'convert seen 0a to 0d 0a newlines')
		    {
			$read =~ s(\x0a)(\x0d\x0a)g;
		    }
		}

		$target_package = "Heterarch::Test::CommandTest::Interactive::Literal";

		# expect $read for output
	    }

	    # if array, means regex match

	    elsif (ref $read eq 'ARRAY')
	    {
		# expect $read to match as a regex with the output

		$target_package = "Heterarch::Test::CommandTest::Interactive::Regex";

	    }

	    # else, hash: one of several alternatives expected

	    else
	    {
		# compose the alternatives regex

		if ($read->{alternatives})
		{
		    # expect that the output literally matches with one of the given alternatives

		    $target_package = "Heterarch::Test::CommandTest::Interactive::Alternatives";

		    my $alternatives = $read->{alternatives};
		}

		# if an application output file is expected

		elsif ($read->{application_output_file})
		{
		    $target_package = "Heterarch::Test::CommandTest::Interactive::File";

		    # read it

		    my $application_output_file = $read->{application_output_file};

		    # and literally compare it with an expected output file or with the {expected_output}

		    my $expected_output_file = $read->{expected_output_file};

		    local $/;

		    my $application_output = `cat "$application_output_file"`;

		    if ($expected_output_file)
		    {
		    }
		    elsif (defined $read->{expected_output})
		    {
		    }
		}

		# if there is a shell command given

		elsif ($read->{shell})
		{
		    $target_package = "Heterarch::Test::CommandTest::Interactive::Shell";

		    # run it and capture its output

		    my $shell = $read->{shell};

		    # and compare its output with the output of the application
		}
		else
		{
		    my $description = $command_test->{description};

		    die "test not understood by $0, aborting (illegal read clause for $description)";
		}
	    }
	}
    }

    # rebless

    bless $command_test, $target_package;

    # return result

    return $command_test;
}


#
# run()
#
# The default implementation executes perl code in the command definition.
#

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # if the command_definition has executable perl code

    if (ref $command eq 'CODE')
    {
	# execute the perl code

	use Cwd;

	my $directory = getcwd();

	my $error
	    = &$command
	    (
	     $self,
	     {
	      c_code => {
			 directory => $directory,
			},
	     },
	    );

	$test_result
	    = {
	       error => $error,
	      };
    }

    # return result

    return $test_result;
}


package Heterarch::Test::CommandTest::CommandObject;


our @ISA = ("Heterarch::Test::CommandTest");


#
# run()
#
# write the write clauses of the command test to the test object.
# expect the contents of the read clause for output.
#

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # record time

    $self->before_testing($execution_context, $fd_output);

    # if the command_definition instantiated an object

    my $command_object = $executor->{command_object};

    # write data to the object using the given methods
    # and arguments and obtain a result from the
    # object

    my $result;

    my $last_method;

    my $writes = $self->{write};

    foreach my $write (@$writes)
    {
	my $method = $write->{method};

	$last_method = $method;

	my $arguments = $write->{arguments};

	$result = $command_object->$method(@$arguments);
    }

    # compare the read data with what is expected

    if (exists $self->{read})
    {
	my $read = $self->{read};

	$test_result
	    = {
	       error => ($result eq $read
			 ? ""
			 : "$last_method returned $result, expected $read"),
	       before_match => $result,
	       expected => $read,
	      };
    }

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive;

#
# The interactive package provides methods for testing interactive
# commands:
#
# - waiting for predetermined amount of time.
#
# - post processing of application results before the test takes
#   place.
#
# - record execution times.
#
# It overrides the ->before_testing() method to conveniently call some
# of these methods.
#
# Derived packages should only override the ->run() method.
#


our @ISA = ("Heterarch::Test::CommandTest");


sub before_testing
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    # record time

    $self->_before_run($execution_context, $fd_output);

    # do write processing

    $self->_process_write($executor, $fd_output);

    # do wait processing

    $self->_process_wait($execution_context, $fd_output);

    # do post processing

    $self->_prepare_run($execution_context, $fd_output);
}


# compute a sensible timeout for interaction with the command that is
# being tested.

sub get_timeout
{
    my $self = shift;

    my $test_startup = $self->{test_startup};

    my $result
	= (defined $self->{timeout}
	   ? $self->{timeout} * $option_timeout_multiplier
	   : ($test_startup
	      ? 4 * $option_timeout_multiplier
	      : 2 * $option_timeout_multiplier));

    return $result;
}


#
# _prepare_run()
#
# Provides processing of a 'shell' clause to post-process results
# generated by the application.
#

sub _prepare_run
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # check the shell command that will be executed with a timeout

    my $shell = $self->{shell};

    if (ref $shell eq 'HASH')
    {
	#! not sure what this can be
    }
    elsif (defined $shell)
    {
	# run the command for a maximum of $timeout seconds

	# allow it to post-process results generated by the command that is being tested

	my $timeout = $self->get_timeout();

	print $fd_output "*** Shell: timeout $timeout $shell\n";

	system "timeout $timeout $shell";

	#t check the output or status of the shell command?

	# fall through
    }

    #t return something sensible

    return $?;
}


sub _process_wait
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    if (exists $self->{wait})
    {
	my $wait = $self->{wait};

	$execution_context->wait($fd_output, $wait);
    }
}


sub _process_write
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $write = $self->{write};

    # write

    if (ref $write eq 'HASH')
    {
    }
    elsif (defined $write)
    {
	print $fd_output "*** Write: $write\n";

	$executor->{expect_object}->send("$write\n");
    }
}


# I believe this is only a template for derived classes.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # try correcting

    my $test_result;

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::ShellTester;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# use the shell command in the tester clause to produce the application output.
#   the shell command should find the produced output and process it.
# compare this output with the expected output.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # if there is an external application to test the final output

    #! the previous shell command was a post-processor, this one is a tester

    my $tester = $self->{tester};

    # set the external tester that compares the generated output with what is expected

    #! the external tester runs an executable shell command

    my $shell = $tester->{shell};

    my $produced = `$shell`;

    my $test_result
	= {
	   expected => defined $tester->{expected} ? $tester->{expected} : '',
	  };

    #			    if ($expected)
    #				$expected = quotemeta $tester->{expected};

    if (($produced eq ''
	 and $test_result->{expected} ne '')
	or ($produced ne ''
	    and $test_result->{expected} eq ''))
    {
	$test_result->{error}
	    = "external tester produces output that is different from what is expected, one is empty, the other is not";

	$test_result->{before_match} = $produced;
    }
    elsif ($produced =~ /$test_result->{expected}/)
    {
    }
    else
    {
	$test_result->{error} = "the external tester produces output that is different from the expected output";

	$test_result->{before_match} = $produced;
    }

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Literal;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# read the application output using the expect object.
# literally compare the application output with the expected output.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # set the expected output

    my $read = $self->{read};

    # if literal text expected

    if (exists $self->{white_space})
    {
	if ($self->{white_space} eq 'convert seen 0a to 0d 0a newlines')
	{
	    print $fd_output "*** Converting seen \\x0a to \\x0d \\x0a newlines\n";

	    $read =~ s(\x0a)(\x0d\x0a)g;
	}
	elsif ($self->{white_space} eq 'convert seen \\x0d \\x0a to \\x0a newlines')
	{
	    print $fd_output "*** Converting seen \\x0d \\x0a to \\x0a newlines\n";

	    $read =~ s(\x0d\x0a)(\x0a)g;
	}
	elsif ($self->{white_space} eq 'convert seen \\x0d \\x0a to \\x0a newlines')
	{
	    print $fd_output "*** Converting seen \\x0d \\x0a to \\x0a newlines\n";

	    $read =~ s(\x0d\x0a)(\x0a)g;
	}
    }

    my $timeout = $self->get_timeout();

    my ($matched_pattern_position,
	$error,
	$successfully_matching_string,
	$before_match,
	$after_match)
	= $executor->{expect_object}->expect($timeout, $read, );

    my $test_result
	= {
	   matched_pattern_position => $matched_pattern_position,
	   error => $error,
	   successfully_matching_string => $successfully_matching_string,
	   before_match => $before_match,
	   after_match => $after_match,
	   expected => $read,
	  };

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Regex;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# read the application output using the expect object.
# compare the application output with the expected output as a regex.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # set the expected output

    my $read = $self->{read};

    # if array, means regex match

    my $timeout = $self->get_timeout();

    my ($matched_pattern_position,
	$error,
	$successfully_matching_string,
	$before_match,
	$after_match)
	= $executor->{expect_object}->expect($timeout, @$read, );

    my $test_result
	= {
	   matched_pattern_position => $matched_pattern_position,
	   error => $error,
	   successfully_matching_string => $successfully_matching_string,
	   before_match => $before_match,
	   after_match => $after_match,

	   #! skip the expect '-re' flag

	   expected => $read->[1],
	  };

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Alternatives;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# read the application output using the expect object.
# compare the application output with the expected output which is a list of alternatives.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # compose the alternatives regex

    my $read = $self->{read};

    my $alternatives = $read->{alternatives};

    my $test_result
	= {
	   expected => '(' . (join '|', map { quotemeta } @$alternatives) . ')',
	  };

    # read from the application

    my $timeout = $self->get_timeout();

    my ($matched_pattern_position,
	$error,
	$successfully_matching_string,
	$before_match,
	$after_match)
	= $executor->{expect_object}->expect($timeout, "-re", $test_result->{expected}, );

    $test_result->{matched_pattern_position} = $matched_pattern_position;
    $test_result->{error} = $error;
    $test_result->{successfully_matching_string} = $successfully_matching_string;
    $test_result->{before_match} = $before_match;
    $test_result->{after_match} = $after_match;

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::File;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# read the application output from a file.
# compare the application output with the expected output which is a file.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # read the application output file

    my $read = $self->{read};

    my $application_output_file = $read->{application_output_file};

    my $pwd = `pwd`;

    chomp $pwd;

    print $fd_output "*** Application output file: $application_output_file (in $pwd)\n";

    # and compare it with the expected output file

    my $expected_output_file = $read->{expected_output_file};

    local $/;

    my $application_output = `cat "$application_output_file"`;

    my $expected_output;

    if ($expected_output_file)
    {
	print $fd_output "*** Expected output file: $expected_output_file\n";

	$expected_output = `cat "$expected_output_file"`;
    }
    elsif (defined $read->{expected_output})
    {
	$expected_output = $read->{expected_output};
    }

    my $test_result
	= {
	   expected => $expected_output,
	  };

    if ($expected_output eq $application_output)
    {
	$test_result->{before_match} = $application_output;
    }
    else
    {
	$test_result->{before_match} = $application_output;

	$read = $expected_output;

	$test_result->{error} = 'expected_output does not match application_output';
    }

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Shell;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


# write the write clauses of the command test.
# run the given shell command and capture its output.
# read the application output using the expect object.
# compare this output with the application output.

sub ct_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # record time, do write, wait processing, pre-processing

    $self->before_testing($execution_context, $executor, $fd_output);

    # run the given shell command and capture its output

    my $read = $self->{read};

    my $shell = $read->{shell};

    my $expected = `$shell`;

    # and compare its output with the output of the application

    my $timeout = $self->get_timeout();

    my ($matched_pattern_position,
	$error,
	$successfully_matching_string,
	$before_match,
	$after_match)
	= $executor->{expect_object}->expect($timeout, $expected, );

    my $test_result
	= {
	   matched_pattern_position => $matched_pattern_position,
	   error => $error,
	   successfully_matching_string => $successfully_matching_string,
	   before_match => $before_match,
	   after_match => $after_match,
	   expected => $expected,
	  };

    # try correcting

    $self->after_testing($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::Element;


our $selected_output_levels;


# could also use Array::Util, but it is not always installed

sub array_union_intersection_difference
{
    my $array1 = shift;

    my $array2 = shift;

    my (@union, @intersection, @difference);

    my %count = ();

    foreach my $element (@$array1, @$array2)
    {
	$count{$element}++
    }

    foreach my $element (keys %count)
    {
	push @union, $element;

	push @{ $count{$element} > 1
		    ? \@intersection
		    : \@difference },
		    $element;
    }

    return ( \@union, \@intersection, \@difference );
}


# sub is_selected() should implement a logical and of the different selection criteria

sub is_selected
{
    my $self = shift;

    my $fd_output = shift;

    # implement a logical and of the different selection criteria

    my $result = $self->is_selected_by_output_level_options($fd_output);

    if ($result)
    {
	$result = $self->is_selected_by_tag($fd_output);
    }

    return $result;

    # my $self = shift;

    # my $fd_output = shift;

    # return $self->is_selected_by_output_level_options($fd_output);
}


sub is_selected_by_output_level_options
{
    my $self = shift;

    my $fd_output = shift;

    # map the selected output levels to a hash to facilitate easy detection what has been enabled

    if (not defined $selected_output_levels)
    {
	$selected_output_levels
	    = {
	       map
	       {
		   my $output_level = $_;

		   my $result = { $output_level => "from options", };

		   %$result;
	       }
	       @$option_output_levels,
	      };
    }

    # convert the class to its output level

    use Scalar::Util 'blessed';

    my $type = defined blessed $self && $self->isa("Heterarch::Test::Module") ? "module" : "";

    $type ||= defined blessed $self && $self->isa("Heterarch::Test::CommandDefinition") ? "command_definition" : "";

    $type ||= defined blessed $self && $self->isa("Heterarch::Test::CommandTest") ? "command_test" : "";

    # determine whether this output level was selected

    my $selected = $selected_output_levels->{$type};

    # return result

    return $selected;
}


# return true if this element definition has a tag that matches the tag options.

sub is_selected_by_tag
{
    my $element_definition = shift;

    my $fd_output = shift;

    my $element_name = $element_definition->{name};

    if (defined $option_debugging
	and $option_debugging eq 'tags')
    {
	use YAML;

	print Dump(
		   {
		    option_debugging => {
					 selected_by_tag_element_name => $element_name,
					},
		   },
		  );
    }

    if (not scalar @$option_tags)
    {
	return ":all";
    }

    my $element_definition_tags = $element_definition->{tags};

    # use Array::Util qw(intersect);

    my ( $union, $intersection, $difference ) = array_union_intersection_difference($element_definition_tags, $option_tags);

    if (scalar @$intersection)
    {
	return $intersection;
    }
    else
    {
	if ($global_test_report->{output_format} eq 'executor')
	{
	    Heterarch::Test::Reporting::report_message_info($fd_output, "Element $element_definition->{description} is not selected by tag (" . (join ", ", @$option_tags ) . " are selected tags).
Total of $global_test_report->{global}->{test_counters}->{command_test} test(s) (encountered $global_error_count error(s) so far)");
	}

	$global_test_report->{not_selected_by_tag}->{elements}->{$element_name} = 'not_selected_by_tag';

	return undef;
    }
}


package Heterarch::Test::ExecutionContext;


#
# _prepare_engine() implements the engine for both preparation and
# reparation that are used for test modules and command definitions.
#
# Returns a ref to a string if an error occurs.  The string describes
# the error that occurred.
#

sub _prepare_engine
{
    my $executor_element = shift;

    my $description = shift;

    my $previous_result = shift;

    my $result = 'nothing executed';

    # either execute regular perl code

    #! in the case of a docker based harness, the code that was
    #! inserted to create the docker image and container, will be
    #! executed here.

    if (ref $executor_element eq 'CODE')
    {
	# print STDERR "sub _prepare_engine(): CODE\n";

	$result = &$executor_element($previous_result);
    }

    # ... or instantiate the object that will do the preparation

    #! this is used to instantiate a web browser and initialize it.

    elsif (exists $executor_element->{class})
    {
	# print STDERR "sub _prepare_engine(): class\n";

	# instantiate the object

	my $class = $executor_element->{class};

	my $filename = $class . ".pm";

	$filename =~ s(::)(/)g;

	require $filename;

	my $executor_element_object = eval "$class->new()";

	# apply all the methods and collect the results

	$result = [];

	my $applicators = $executor_element->{applicators};

	foreach my $applicator (@$applicators)
	{
	    my $method = $applicator->{method};

	    my $arguments = $applicator->{arguments};

	    my $applicator_result = $executor_element_object->$method($arguments);

	    if (ref $applicator_result eq 'SCALAR')
	    {
		$result = \ "Error: $description failed ($$applicator_result)";

		last;
	    }

	    push @$result, $applicator_result;
	}
    }

    # or execute an array of system shell commands

    elsif (exists $executor_element->{system_commands})
    {
	# print STDERR "sub _prepare_engine(): system_commands\n";

	my $system_commands = $executor_element->{system_commands};

	if (ref $system_commands eq 'ARRAY')
	{
	    foreach my $system_command (@$system_commands)
	    {
		system $system_command;

		if ($? ne 0)
		{
		    $result = \ "Error: $description failed ($system_command)";

		    last;
		}
	    }
	}
    }

    # return result

    return $result;
}


sub _get_current
{
    my $self = shift;

    my $path = $self->{path};

    my $current = $path->[$#$path];

    return $current;
}


#t to be replaced with instance variables

our $command_definition_counter_per_module = 0;
our $command_definition_counter_global = 0;

our $command_test_counter_per_command_definition = 0;
our $command_test_counter_per_module = 0;
our $command_test_counter_global = 0;

our $module_counter_global = 0;


sub _maintain_counters
{
    my $self = shift;

    my $current = shift;

    my $command_definition = $current->[1];

    my $command_test = $current->[2];

    my $module_definition = $current->[0];

    if (defined $command_test)
    {
	$command_test_counter_global++;
	$command_test_counter_per_module++;
	$command_test_counter_per_command_definition++;
    }
    elsif (defined $command_definition)
    {
	$command_definition_counter_global++;
	$command_definition_counter_per_module++;

	$command_test_counter_per_command_definition = 0;
    }
    elsif (defined $module_definition)
    {
	$module_counter_global++;

	$command_definition_counter_per_module = 0;
	$command_test_counter_per_module = 0;
    }
    else
    {
	die "$0: internal error when _maintain_counters(): nothing left to count\n";
    }
}


sub _push_current
{
    my $self = shift;

    my $current = shift;

    my $path = $self->{path};

    push @$path, $current;

    $self->_maintain_counters($current);

}


sub _pop_current
{
    my $self = shift;

    my $path = $self->{path};

    my $result = pop @$path;

    return $result;
}


sub _push_preparation_result
{
    my $self = shift;

    my $preparation_result = shift;

    my $path = $self->{preparation_result};

    push @$path, $preparation_result;

}


sub _pop_preparation_result
{
    my $self = shift;

    my $path = $self->{preparation_result};

    my $result = pop @$path;

    return $result;
}


sub _top_preparation_result
{
    my $self = shift;

    my $path = $self->{preparation_result};

    my $result = $path->[$#$path];

    return $result;
}


sub ec_end
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    #! note: reparation_error has already been processed

    my $reparation_error = $self->_reparation();

    if ($global_test_report->{output_format} eq 'executor')
    {
	my $fd_output = $self->{fd_output};

	my $module_name = $module_definition->{name};

	my $description;

	my $name;

	if (defined $command_test)
	{
	    $description = $command_test->{description} ? "*** Test: $command_test->{description}" : "(Warning: no description of this command_test when ending the execution context)";

	    $name = "";
	}
	elsif (defined $command_definition)
	{
	    $description = $command_definition->{description} ? "command $command_definition->{description}" : "(Warning: no description of this command_definition when ending the execution context)";

	    $name = " ($command_definition->{command})";
	}
	else
	{
	    $description = "module $module_definition->{description}";

	    $name = " ($module_definition->{name})";
	}

	if (defined $command_test)
	{
	    # no output here, the test output is emitted in ->ec_examine()
	}
	else
	{
	    Heterarch::Test::Reporting::report_message_end($fd_output, "End for tests of $description
Total of $global_test_report->{global}->{test_counters}->{command_test} test(s) (encountered $global_error_count error(s) so far)");
	}
    }

    $self->_pop_current();
}


sub get_command_definition
{
    my $self = shift;

    my $current = $self->_get_current();

    my $command_definition = $current->[1];

    return $command_definition;
}


sub get_command_definition_counter_per_module
{
    my $self = shift;

    #t to be replaced with instance variables

    return $command_definition_counter_per_module;
}


sub get_command_test
{
    my $self = shift;

    my $current = $self->_get_current();

    my $command_test = $current->[2];

    return $command_test;
}


sub get_command_test_counter_per_command_definition
{
    my $self = shift;

    #t to be replaced with instance variables

    return $command_test_counter_per_command_definition;
}


sub get_context_path
{
    my $self = shift;

    # add module counter and identifier

    my $result = $self->get_module_definition_counter();

    $result .= "_";

    $result .= $self->get_module_definition()->{name};

    # add command_definition counter and identifier

    my $command_definition = $self->get_command_definition();

    if (defined $command_definition)
    {
	$result .= "_";

	$result .= $self->get_command_definition_counter_per_module();

	$result .= "_";

	# the command_definition identifier is based on the system
	# shell command that is used to perform the tests

	if (exists $command_definition->{command})
	{
	    $result .= $command_definition->{command};
	}
	else
	{
	    $result .= "NONE";
	}

	# add command_test counter and identifier

	my $command_test = $self->get_command_test();

	if (defined $command_test)
	{
	    $result .= "_";

	    $result .= $self->get_command_test_counter_per_command_definition();

	    $result .= "_";

	    # the command_test identifier is based on the write clause

	    if (exists $command_test->{write}
		and defined $command_test->{write})
	    {
		$result .= $command_test->{write};
	    }
	    else
	    {
		$result .= "NONE";
	    }
	}
    }

    # return result

    return $result;
}


sub get_module_definition
{
    my $self = shift;

    my $current = $self->_get_current();

    my $module_definition = $current->[0];

    return $module_definition;
}


sub get_module_definition_counter
{
    my $self = shift;

    #t to be replaced with instance variables

    return $module_counter_global;
}


sub has_error_flag
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $error = $active_element->{error};

    my $description = $active_element->{description};

    if ($error)
    {
	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => $description,
		  error => "this test was tagged with the error flag",
		  module_name => $module_name,
		  subdescription => $error,
		 },
		);

	return 1;
    }
    else
    {
	return 0;
    }
}


sub is_disabled
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $disabled = $active_element->{disabled};

    if ($disabled)
    {
	my $description = $active_element->{description};

	my $report_key
	    = (defined $command_test
	       ? "command_tests"
	       : (defined $command_definition
		  ? "command_definitions"
		  : "modules"));

	$global_test_report->{disabled}->{$report_key}->{$module_name}->{$description} = $disabled;

	if ($global_test_report->{output_format} eq 'executor')
	{
	    Heterarch::Test::Reporting::report_message_info($fd_output, "Tests of $description are disabled ($disabled)
Total of $global_test_report->{global}->{test_counters}->{command_test} test(s) (encountered $global_error_count error(s) so far)");
	}

	return 1;
    }
    else
    {
	return 0;
    }
}


sub ec_is_selected
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $result = $active_element->is_selected($fd_output);

    return $result;
}


sub _preparation
{
    my $self = shift;

    my $current = $self->_get_current();

    my $module_definition = $current->[0];

    my $command_definition = $current->[1];

    my $command_test = $current->[2];

    # command_tests with a harnessing clause are unsupported, they
    # cannot be 'prepared'.

    if ($command_test)
    {
	return undef;
    }

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    if ($command_definition)
    {
	if (exists $command_definition->{preparation}
	    and exists $command_definition->{harnessing})
	{
	    die "$0: command_definition ($command_definition->{description}) has both a preparation and harnessing clause\n";
	}
    }
    else
    {
	if (exists $module_definition->{preparation}
	    and exists $module_definition->{harnessing})
	{
	    die "$0: module_definition ($module_definition->{description}) has both a preparation and harnessing clause\n";
	}
    }

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    # convert the old format preparation / reparation to the new format of harnessing

    if (not exists $active_element->{harnessing})
    {
	if (exists $active_element->{preparation})
	{
	    $active_element->{harnessing}->{preparation} = $active_element->{preparation};

	    delete $active_element->{preparation};
	}

	if (exists $active_element->{reparation})
	{
	    $active_element->{harnessing}->{reparation} = $active_element->{reparation};

	    delete $active_element->{reparation};
	}
    }

    # process the harnessing preparation clause

    my $harnessing = $active_element->{harnessing};

    use Clone 'clone';

    my $preparation = clone($harnessing->{preparation});

    my $preparation_result;

    my $all_preparation_harnessess = [];

    if (defined $preparation)
    {
	push @$all_preparation_harnessess, { description => 'Instantiated', preparation => $preparation, };
    }

    # if we are really running tests

    #t I have the impression this should be implemented through an
    #t method call rather than an if clause, see also identical comments.

    if ($global_test_report->{output_format} eq 'executor')
    {
	# if there is a docker container preparation

	if (exists $harnessing->{class})
	{
	    my $harnessing_class = $harnessing->{class};

	    my $harnessing_identifier = $harnessing_class->{identifier};

	    my $harness = Heterarch::Test::ExecutionContext::Harness::create_or_fetch($harnessing_class, $harnessing_identifier);

	    # add it to the list of preparation harnesses, make sure
	    # it gets executed before the other ones

	    unshift @$all_preparation_harnessess, $harness;
	}

	# while there are preparation clauses

	foreach my $preparation_harness (@$all_preparation_harnessess)
	{
	    if ($preparation_harness->{description} eq 'Executed')
	    {
		my $preparation = $preparation_harness->{preparation};

		# give diagnostics

		my $preparation_name
		    = ($command_definition
		       ? "command '$command_definition->{command}'"
		       : "module '$module_definition->{name}'");

		Heterarch::Test::Reporting::report_message($fd_output, "*** Preparation $preparation_name was already executed ($preparation->{description})");

		$preparation_result = $preparation_harness->{preparation_result};
	    }
	    elsif ($preparation_harness->{description} eq 'Instantiated')
	    {
		my $preparation = $preparation_harness->{preparation};

		# give diagnostics

		my $preparation_name
		    = ($command_definition
		       ? "command '$command_definition->{command}'"
		       : "module '$module_definition->{name}'");

		Heterarch::Test::Reporting::report_message($fd_output, "*** Preparing $preparation_name ($preparation->{description})");

		# execute the preparation clause

		my $preparer = $preparation->{preparer};

		$preparation_result = _prepare_engine($preparer, 'preparation');

		$preparation_harness->{preparation_result} = $preparation_result;

		# if the preparer returned an error string

		my $preparation_error;

		if (ref $preparation_result eq 'SCALAR')
		{
		    # obtain the error string

		    $preparation_error = $$preparation_result;

		    $preparation_harness->{preparation_error} = $preparation_error;
		}

		# process errors

		if ($preparation_error)
		{
		    my $module_name = $module_definition->{name};

		    my $subdescription
			= ($command_definition
			   ? $command_definition->{description}
			   : $module_definition->{description});

		    Heterarch::Test::Reporting::report_error_add
			    (
			     $fd_output,
			     {
			      description => $preparation_name,
			      error => $preparation_error,
			      module_name => $module_name,
			      subdescription => $subdescription,
			     },
			    );

		    $preparation_harness->{description} = 'In error ($preparation_error)';
		}
		else
		{
		    $preparation_harness->{description} = 'Executed';
		}
	    }
	}
    }

    # return result

    return $preparation_result;
}


sub new
{
    my $package = shift;

    my $fd_output = shift;

    my $options = shift || {};

    my $self
	= {
	   %$options,
	   fd_output => $fd_output,
	   path => [],
	   preparation_result => [],
	  };

    bless $self, $package;

    return $self;
}


sub _reparation
{
    my $self = shift;

    my $current = $self->_get_current();

    my $module_definition = $current->[0];

    my $command_definition = $current->[1];

    my $command_test = $current->[2];

    my $preparation_result = $self->_pop_preparation_result();

    # command_tests with a harnessing clause are unsupported

    if ($command_test)
    {
	return undef;
    }

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $module_name = $module_definition->{name};

    # process the harnessing reparation clause

    my $harnessing
	= ($command_definition
	   ? $command_definition->{harnessing}
	   : $module_definition->{harnessing});

    use Clone 'clone';

    my $reparation = clone($harnessing->{reparation});

    my $reparation_error;

    my $all_reparation_harnesses = [];

    if (defined $reparation)
    {
	push @$all_reparation_harnesses, { description => 'Instantiated', reparation => $reparation, };
    }

    # if there is a reparation clause

    if ($global_test_report->{output_format} eq 'executor')
    {
	# if there is a docker container reparation

	if (exists $harnessing->{class})
	{
	    my $harnessing_class = $harnessing->{class};

	    my $harnessing_identifier = $harnessing_class->{identifier};

	    my $harness = Heterarch::Test::ExecutionContext::Harness::fetch($harnessing_class, $harnessing_identifier);

	    push @$all_reparation_harnesses, $harness;
	}

	foreach my $reparation_harness (@$all_reparation_harnesses)
	{
	    my $reparation = $reparation_harness->{reparation};

	    # give diagnostics

	    my $fd_output = $self->{fd_output};

	    my $reparation_description = $reparation->{description};

	    Heterarch::Test::Reporting::report_message($fd_output, "*** Reparing ($reparation_description)");

	    # execute the reparation clause

	    my $reparer = $reparation->{reparer};

	    $reparation_error = _prepare_engine($reparer, 'reparation', $preparation_result);

	    # process errors

	    if ($reparation_error)
	    {
		my $module_name = $module_definition->{name};

		my $subdescription
		    = ($command_definition
		       ? $command_definition->{description}
		       : $module_definition->{description});

		Heterarch::Test::Reporting::report_error_add
			(
			 $fd_output,
			 {
			  description => $reparation_description,
			  error => $reparation_error,
			  module_name => $module_name,
			  subdescription => $subdescription,
			 },
			);
	    }
	}
    }

    return $reparation_error;
}


#
# sub ec_examine
#
# Apply selection criteria to the current context.
# Prepare the test environment by execution of the preparation clause.
#
# This is called for a module definition, a command definition and a
# test.
#

sub ec_examine
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    # set default result: everything ok

    my $result;

    # if this element is selected by active options

    if (not $self->ec_is_selected($module_definition, $command_definition, $command_test))
    {
	return "not selected";
    }

    # if this test is disabled

    if ($self->is_disabled($module_definition, $command_definition, $command_test))
    {
	# return to skip it

	return "is disbled";
    }

    # if this test has been flagged with an error

    #t when output pdf or html the error flag message should be
    #t included in the output but error counting should be skipped

    if ($self->has_error_flag($module_definition, $command_definition, $command_test))
    {
	# return to skip it

	return "has the error flag";;
    }

    # update the path of execution

    $self->_push_current( [ $module_definition, $command_definition, $command_test, ] );

    # give diagnostics

    #t I have the impression this should be implemented through an
    #t method call rather than an if clause, see also identical comments.

    if ($global_test_report->{output_format} eq 'executor')
    {
	my $fd_output = $self->{fd_output};

	my $comment;

	my $description;

	my $name;

	if (defined $command_test)
	{
	    $comment = $command_test->{comment};

	    $description = $command_test->{description} ? "*** Test: $command_test->{description}" : "(Warning: no description of this command_test when examining the execution context)";

	    $name = "";
	}
	elsif (defined $command_definition)
	{
	    $comment = $command_definition->{comment};

	    $description = $command_definition->{description} ? "command $command_definition->{description}" : "(Warning: no description of this command_definition when examining the execution context)";

	    $name = " ($command_definition->{command})";
	}
	else
	{
	    $comment = $module_definition->{comment};

	    $description = "module $module_definition->{description}";

	    $name = " ($module_definition->{name})";
	}

	if (defined $command_test)
	{
	    Heterarch::Test::Reporting::report_message($fd_output, "$description");
	}
	else
	{
	    Heterarch::Test::Reporting::report_message_start($fd_output, "Running tests of $description$name");
	}

	if ($comment)
	{
	    Heterarch::Test::Reporting::report_message($fd_output, "*** Comment: $comment");
	}
    }

    # prepare the test environment

    my $preparation_result = $self->_preparation();

    $self->_push_preparation_result($preparation_result);

    # return result: should be undef here

    return $result;
}


sub ec_terminate
{
    my $self = shift;

    my $fd_output = $self->{fd_output};

    my $path = $self->{path};

    if (scalar @$path)
    {
	my $module_definition = $self->get_module_definition();

	my $description = "module $module_definition->{description}";

	my $module_name = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
	    (
	     $fd_output,
	     {
	      description => "execution context invalid",
	      error => "left over elements in the execution context after it was terminated",
	      module_name => $module_name,
	     },
	    );
    }
}


sub wait
{
    my $self = shift;

    my $fd_output = shift;

    my $wait = shift;

    # wait

    if ($wait)
    {
	print $fd_output "*** Wait: $wait seconds\n";

	select(undef, undef, undef, $wait);
    }
}


package Heterarch::Test::ExecutionContext::Harness;

my $global_active_harness_identifiers = [];

my $global_harnessing_identifiers = {};


sub current
{
    if (defined $option_debugging
	and $option_debugging eq 'harnessing')
    {
	use YAML;

	print Dump(
		   {
		    option_debugging => {
					 global_active_harness_identifiers => $global_active_harness_identifiers,
					 global_harnessing_identifiers => $global_harnessing_identifiers,
					},
		   },
		  );
    }

    my $active_harness_identifier
	= $global_active_harness_identifiers->[$#$global_active_harness_identifiers];

    my $active_harness;

    if (defined $active_harness_identifier)
    {
	$active_harness = $global_harnessing_identifiers->{$active_harness_identifier};
    }

    return $active_harness;
}


sub create_or_fetch
{
    my $harnessing_class = shift;

    my $harnessing_identifier = shift;

    my $result;

    # if this was not executed yet

    if (not exists $global_harnessing_identifiers->{$harnessing_identifier})
    {
	# prepare the docker image and container

	my $build = $harnessing_class->{build};
	my $identifier = $harnessing_class->{identifier};
	my $name_container = $harnessing_class->{name_container};
	my $name_image = $harnessing_class->{name_image};
	my $type = $harnessing_class->{type};

	my $docker_preparer
	    = (sub
	       {
		   # build the container

		   system "$build";

		   if ($?)
		   {
		       return 'docker_preparer build command failed';
		   }

		   # try to stop and remove a previous container of the same name

		   system "sudo docker container stop $name_container";
		   system "sudo docker container rm $name_container";

		   # start the newly built container

		   system "sudo docker run -d -t --name $name_container $name_image";

		   # make the docker harness available by pushing it

		   push @$global_active_harness_identifiers, $harnessing_identifier;

		   # return no errors

		   return '';
	       });

	my $docker_reparer
	    = (sub
	       {
		   # remove the docker harness

		   pop @$global_active_harness_identifiers;

		   print "The Docker container is still running.\n
You can enter it by executing 'sudo docker exec -it $name_container bash'.\n\n";

		   system "sudo docker container ls";

		   # return no errors

		   return '';
	       });

	my $docker_preparation
	    = {
	       description => "create the Docker image and start it as a container for running the tests",
	       preparer => $docker_preparer,
	      };

	my $docker_reparation
	    = {
	       description => "leave the Docker container for running manual tests",
	       reparer => $docker_reparer,
	      };

	use Clone 'clone';

	my $harness
	    = {
	       class => clone($harnessing_class),
	       description => 'Instantiated',
	       command_prefix_long => {
				       const => [
						 'sudo',
						 'docker',
						 'exec',
						 '-it',
						],
				       container_name => $name_container,
				       prefix_command => [
							  'bash',
							  '-ic',
							 ],
				       user => $harnessing_class->{default_user},
				      },
	       command_prefix_short => [
					'sudo',
					'docker',
					'exec',
					'-it',
					$name_container,
				       ],
	       preparation => $docker_preparation,
	       reparation => $docker_reparation,
	      };

	bless $harness, 'Heterarch::Test::ExecutionContext::Harness';

	$global_harnessing_identifiers->{$harnessing_identifier} = $harness;

	$result = $global_harnessing_identifiers->{$harnessing_identifier};
    }
    else
    {
	# the harnessing identifier exists means that the docker container is running

	$result = $global_harnessing_identifiers->{$harnessing_identifier};
    }

    # return the result

    return $result;
}


sub fetch
{
    my $harnessing_class = shift;

    my $harnessing_identifier = shift;

    my $result;

    # if this was not executed yet

    if (not exists $global_harnessing_identifiers->{$harnessing_identifier})
    {
    }
    else
    {
	# the harnessing identifier exists means that the docker container is running

	$result = $global_harnessing_identifiers->{$harnessing_identifier};
    }

    # return the result

    return $result;
}


sub generate_command_prefix
{
    my $self = shift;

    my $command_definition = shift;

    my $execution_context = shift;

    my $command_prefix_long = $self->{command_prefix_long};

    my $const = $command_prefix_long->{const};

    my $container_name = $command_prefix_long->{container_name};

    my $prefix_command = $command_prefix_long->{prefix_command};

    my $user = (exists $command_definition->{command_user}
		? $command_definition->{command_user}
		: $command_prefix_long->{user});

    my $command_prefix = [ @$const, '--user', $user, $container_name, @$prefix_command, ];

    return $command_prefix;
}


package Heterarch::Test::Executor;

#
# This is the default Heterarch::Test::Executor.  It provides a link
# with the execution context and implements ->ex_mo_prepare(),
# ->ex_cd_start() and ->ex_ct_run() methods that call the appropriate
# module, command_definition and command_test methods for implementing
# test execution.
#


sub new
{
    my $package = shift;

    my $execution_context = shift;

    my $fd_output = $execution_context->{fd_output};

    my $options = shift || {};

    my $self
	= {
	   %$options,
	   execution_context => $execution_context,
	   fd_output => $fd_output,
	  };

    bless $self, $package;

    return $self;
}


#
# Create the infrastructure for keeping module test results.
#
# For a base executor, this is currently a no-op.
#
# There is currently a global infrastructure for storing real test
# results, rather than a local one.
#

sub ex_mo_prepare
{
    my $self = shift;

}


#
# ->run() is called to execute one command test.
#
# this executor trivially delegates this call to the command_test object
#
# A derived class can inspect the elements found in the test
# specification and, for instance, print them to a file.
#

sub ex_ct_run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $fd_output = $self->{fd_output};

    return $command_test->ct_run($execution_context, $self, $fd_output);
}


#
# ->start() is called to start the tests of a single command definition.
#
# It instantiate the tester:
#
# 1. an object given its class.
# 2. a piece of perl code that is run.
# 3. an interactive system shell command.
#

sub ex_cd_start
{
    my $self = shift;

    my $execution_context = $self->{execution_context};

    my $module_definition = $execution_context->get_module_definition();

    my $command_definition = $execution_context->get_command_definition();

    my $fd_output = $self->{fd_output};

    $command_definition->cd_start($self, $fd_output);

    # process the command_definition specific clauses

    #! this sloppy implementation works around a too elaborate
    #! object-oriented based implementation that would require
    #! to call SUPER class methods inside ->cd_start().

    $command_definition->process_clauses($execution_context, $fd_output);
}


sub ex_terminate
{
    my $self = shift;

    my $fd_output = shift;

    my $test_module_library_contents = shift;

    # yaml out the test report

    my $report_yaml
	= {
	   description => $global_test_report->{description},
	  };

    # add output specific to the output selection

    if ($option_report_disabled)
    {
	$report_yaml->{disabled} = $global_test_report->{disabled};
    }

    $report_yaml->{errors} = $global_test_report->{errors};
    $report_yaml->{global} = $global_test_report->{global};

    use YAML;

    my $report_text = "\n" . Dump($report_yaml);

    print $global_fd_output "$report_text\n";

    #! this could be an error message

    return undef;
}


package Heterarch::Test::Library;


sub construct
{
    # find the test specifications

    my $test_modules
	= [
	   map
	   {
	       chomp; $_;
	   }
	   sort
	   `find $global_config->{tests_directory} -name "*.t"`,
	  ];

    return $test_modules;
}


sub expand
{
    my $fd_output = shift;;

    my $library = shift;

    my $test_modules = [];

    # read the introduction

    my $html_introduction;

    my $html_introduction_filename = $global_config->{introduction_filename};

    if (-e $html_introduction_filename)
    {
	local $/; # enable 'slurp' mode

	my $file = IO::File->new("<$html_introduction_filename");

	$html_introduction = <$file>;

	$file->close();
    }
    else
    {
	$html_introduction = '';
    }

    # parse all modules

    foreach my $test_module (@$library)
    {
	if ($test_module !~ /$option_regex_selector/i)
	{
	    next;
	}

	my $module_definition = readfile($fd_output, $test_module);

	if ($module_definition)
	{
	    push @$test_modules, $module_definition;
	}
    }

    if ($option_flattenout)
    {
	# sort modules

	#t first need to transform: select command_definitions, flatten
	#t out, keep the module names (for referencing errors).

	my $transformator
	    = Data::Transformator->new
		(
		 apply_identity_transformation => 0,
		 name => 'test-module-selector',
		 contents => $test_modules,
		 separator => '`',
		 array_filter =>
		 sub
		 {
		     my ($context, $component) = @_;

		     # never filter for the first two component in the path

		     my $depth = $context->{array};
		     $depth = $#$depth;

		     if ($depth < 2)
		     {
			 return 1;
		     }

		     # extract the data: command definitions with test commands

		     $context->{path} =~ m|^[^/]*/([^/]*)/([^/]*)|;

		     my $content = Data::Transformator::_context_get_current_content($context);

		     # push it onto the result

		     my $result = Data::Transformator::_context_get_main_result($context);

		     if (!$result->{content})
		     {
			 $result->{content} = [];
		     }

		     push @{$result->{content}}, $content;

		     # add the module name

		     my $module_name = $context->{array}->[1]->{content}->{name};

		     $content->{module_name} = $module_name;

		     # add the module description

		     my $module_description = $context->{array}->[1]->{content}->{description};

		     $content->{module_description} = $module_description;

		     # result is known, everything gets filtered

		     0;
		 },
		);

	#t for an empty array as content, the transformator returns an
	#t undef, this is a bug that still needs fixing.

	my $tests = $transformator->transform() || [];

	# sort the flattened test definitions

	$tests
	    = [
	       sort
	       {
		   my $module1 = $a;
		   my $module2 = $b;

		   my $command1 = $module1->{command};
		   my $command2 = $module2->{command};

		   my $command1_arguments = $module1->{arguments} || [];
		   my $command2_arguments = $module2->{arguments} || [];

		   my $command1_string = join ' ', $command1, @$command1_arguments;
		   my $command2_string = join ' ', $command2, @$command2_arguments;

		   my $comparison = $command1_string cmp $command2_string;

		   if ($module1->{tester_head})
		   {
		       $comparison = -1;
		   }
		   elsif ($module2->{tester_head})
		   {
		       $comparison = 1;
		   }

		   $comparison;
	       }
	       @$tests,
	      ];

	# transform back to the regular test module format by putting
	# every command definition in its own module

	$tests
	    = [
	       map
	       {
		   my $command_definition = $_;

		   (
		    {
		     command_definitions => [
					     $command_definition,
					    ],
		     description => $command_definition->{module_description},
		     name => $command_definition->{module_name},
		    }
		   );
	       }
	       @$tests,
	      ];

	# set result

	$test_modules = $tests;
    }

    # set result

    my $result
	= {
	   html_introduction => $html_introduction,
	   test_modules => $test_modules,
	  };

    # return result

    return $result;
}


sub is_json
{
    my $filename = shift;

    my $result;

    use IO::File;

    my $fh = IO::File->new();

    if ($fh->open("< $filename"))
    {
	my $first_line = <$fh>;

	$first_line =~ s/(\s)*//g;

	if ($first_line =~ m'^\{')
	{
	    $result = 'is_json';
	}

	$fh->close;
    }

    return $result;
}


sub is_yaml
{
    my $filename = shift;

    my $result;

    use IO::File;

    my $fh = IO::File->new();

    if ($fh->open("< $filename"))
    {
	my $first_line = <$fh>;

	$first_line =~ s/(\s)*//g;

	if ($first_line eq '---')
	{
	    $result = 'is_yaml';
	}

	$fh->close;
    }

    return $result;
}


sub randomize_order
{
    my $test_modules = shift;

    my $random_seed = shift;

    # by default the randomizer will choose a random_seed

    if (not defined $random_seed)
    {
	$random_seed = time() ^ $$ ^ unpack "%L*", `ps axww | gzip`;
    }

    # set the random_seed

    srand($random_seed);

    # and shuffle the modules

    require List::Util;

    return ( [ List::Util::shuffle(@$test_modules), ], $random_seed );
}


sub readfile
{
    my $fd_output = shift;

    my $pathname = shift;

    my $result;

    if (is_yaml($pathname))
    {
	use YAML;

	$result = YAML::LoadFile($pathname);

	if ($@)
	{
	    report_error_add
	    (
	     $fd_output,
	     {
	      description => $@,
	      error => $@,
	      module_name => $pathname,
	     },
	    );
	}
    }
    elsif (is_json($pathname))
    {
	local $/; # enable 'slurp' mode

	my $file = IO::File->new("<$pathname");

	my $json_text = <$file>;

	$file->close();

	use JSON;

	my $json = JSON->new();

	#! allow code refs, they are converted to nulls

	$json->allow_unknown(1);

	$result = $json->decode($json_text);

	if ($@)
	{
	    report_error_add
	    (
	     $fd_output,
	     {
	      description => $@,
	      error => $@,
	      module_name => $pathname,
	     },
	    );
	}
    }
    else
    {
	$result = do $pathname;

	if ($@)
	{
	    Heterarch::Test::Reporting::report_error_add
		    (
		     $fd_output,
		     {
		      description => $@,
		      error => $@,
		      module_name => $pathname,
		     },
		    );
	}
    }

    $pathname =~ m((.*)/(.*));

    my $filename = $2;

    if ($option_dump_json)
    {
	use JSON;

	my $json = JSON->new();

	#! allow code refs, they are converted to nulls

	$json->allow_unknown(1);

	my $file = IO::File->new(">/tmp/$filename.js");

	print $file $json->encode($result);

	$file->close();
    }

    if ($option_dump_perl)
    {
	use Data::Dumper;

	my $file = IO::File->new(">/tmp/$filename.pl");

	print $file Dumper($result);

	$file->close();
    }

    if ($option_dump_yaml)
    {
	YAML::DumpFile("/tmp/$filename.yml", $result);
    }

    # check if the name of the test and the pathname match

    if ($option_check_test_names)
    {
	if ($pathname ne "$global_config->{tests_directory}/$result->{name}")
	{
	    Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		     description => "the pathname ($pathname) and the test name ($result->{name}) are different",
		     error => "the pathname ($pathname) and the test name ($result->{name}) are different",
		     module_name => $pathname,
		 },
		);
	}
    }

    return $result;
}


package Heterarch::Test::Module;


our @ISA = ("Heterarch::Test::Element");


sub check_description
{
    my $module_definition = shift;

    my $fd_output = shift;

    my $module_name = $module_definition->{name};

    if (!defined $module_definition->{description})
    {
	$module_definition->{description} = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => 'no module description',
		  error => 'no module description',
		  module_name => $module_name,
		 },
		);
    }

    return $module_definition->{description};
}


sub check_name
{
    my $module_definition = shift;

    my $fd_output = shift;

    if (!defined $module_definition->{name})
    {
	$module_definition->{name} = 'unnamed';

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => 'unnamed module',
		  error => 'unnamed module',
		  module_name => 'unnamed module',
		 },
		);
    }

    return $module_definition->{name};
}


# sub is_selected
# {
#     my $self = shift;

#     my $fd_output = shift;

#     # implement a logical and of the different selection criteria

#     my $result = $self->SUPER::is_selected($fd_output);

#     if ($result)
#     {
# 	$result = $self->is_selected_by_tag($fd_output);
#     }

#     return $result;
# }


# check if this module is ready to run its tests.
# execute all the command definitions.
# execute all the command tests in these command definitions.

sub md_run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $module_name = $self->check_name($fd_output);

    my $module_description = $self->check_description($fd_output);

    # do selection and prepare the test environment

    my $not_started = $execution_context->ec_examine($self);

    if ($not_started)
    {
	return "module start failed ($not_started)";
    }

    # create the infrastructure for keeping module test results

    #! for a base executor, this is currently a no-op.

    $executor->ex_mo_prepare();

    # loop over commands for this module

    my $command_definitions = $self->{command_definitions};

    foreach my $command_definition (@$command_definitions)
    {
	bless $command_definition, "Heterarch::Test::CommandDefinition";

	# lookup the class for this command definition

	$command_definition->rebless();

	# do selection and prepare the test environment

	my $not_started = $execution_context->ec_examine($self, $command_definition);

	if ($not_started)
	{
	    next;
	}

	# call the perl code, spaw_new

	# 1. an object given its class.
	# 2. a piece of perl code that is run.
	# 3. an interactive system shell command.

	$executor->ex_cd_start();

	# loop over all tests for this command

	my $command_tests = $command_definition->{command_tests};

	foreach my $command_test (@$command_tests)
	{
	    bless $command_test, "Heterarch::Test::CommandTest";

	    # lookup the class for this command test

	    $command_test->rebless();

	    # emit comment if any

	    my $not_started = $execution_context->ec_examine($self, $command_definition, $command_test);

	    if ($not_started)
	    {
		next;
	    }

	    # run the text executor which will run the command_test

	    my $execution_result = $executor->ex_ct_run($command_test);

	    # process errors

	    my $error = $execution_result->{error};

	    if ($error)
	    {
		my $description = $command_test->{description};

		my $command_definition_description = $command_definition->{description};

		my $message;

		my $before_match = $execution_result->{before_match};

		#! wondering what option_verbose has to do with the reporting of errors

		if ($option_verbose)
		{
		    $message = $before_match;
		}

		Heterarch::Test::Reporting::report_error_add
			(
			 $fd_output,
			 {
			  description => $description,
			  error => $error,
			  expected => $execution_result->{expected},
			  message => $message,
			  module_name => $module_name,
			  seen => $before_match,
			  subdescription => $command_definition_description,
			 },
			);
	    }

	    # end the execution of this test

	    $execution_context->ec_end($self, $command_definition, $command_test);

	    # register if this command had side effects

	    $global_previous_command_side_effects ||= $command_test->{side_effects} || 0;

	    # increment command test count

	    $global_test_report->{global}->{test_counters}->{command_test}++;
	}

	# repair the command test environment

	$execution_context->ec_end($self, $command_definition);

	# register if this command had side effects

	#! e.g. using a preparer/reparer combination

	$global_previous_command_side_effects ||= $command_definition->{side_effects} || 0;

	# increment command definition test count

	$global_test_report->{global}->{test_counters}->{command_definition}++;
    }

    # repair the test environment

    $execution_context->ec_end($self);

    # register if this command had side effects

    #! don't think this make sense, but anyway ...

    $global_previous_command_side_effects ||= $self->{side_effects} || 0;

    # if library checksum mismatch

    if (defined ($global_config->{model_library}))
    {
	my $library_sha_before = $execution_context->{library_sha_before};

	my $library_sha_after = ModelLibrary::sha();

	if ($library_sha_after ne $library_sha_before)
	{
	    my $error = 'model library checksum mismatch (model library has changed)';

	    my $description = $self->{description};

	    Heterarch::Test::Reporting::report_error_add
		    (
		     $fd_output,
		     {
		      description => $description,
		      error => $error,
		      module_name => $module_name,
		     },
		    );
	}
    }

    # increment module definition test count

    $global_test_report->{global}->{test_counters}->{module_definition}++;

    # return result: execution completed

    return '';
}


package Heterarch::Test::Output;

#
# An Heterarch::Test::Output is an Heterarch::Test::Executor that
# generates output rather than executing tests.  The
# Heterarch::Test::Executor provides a link with the execution context
# and implements ->ex_mo_prepare(), ->ex_cd_start() and ->ex_ct_run()
# methods that call the appropriate module, command_definition and
# command_test methods for implementing test execution.
#
# The Heterarch::Test::Output implements ->ex_mo_prepare(),
# ex_cd_start() and ex_ct_run() methods to select content and prepare
# a structure for generating output of different format (HTML, XML,
# Yaml, Ascii).
#

our @ISA = ("Heterarch::Test::Executor");


package Heterarch::Test::Output::Summarizer;

#
# A Heterarch::Test::Output::Summarizer implements ->ex_mo_prepare(),
# ex_cd_start() and ex_ct_run() methods that select content and
# prepare a structure for generating a summary in YAML of this
# selection.
#

our @ISA = ("Heterarch::Test::Output");


package Heterarch::Test::Output::Formatter;

#
# A Heterarch::Test::Output::Formatter implements ->ex_mo_prepare(),
# ->ex_cd_start() and ->ex_ct_run() methods that prepare structure
# content for the output formatter to convert to its target format.
#
# The result of the conversion is stored in the hash
# $global_test_report->{selected}.
#
# This hash has the selected module names as keys.  Each value is a
# hash with the contents of the module and a key
# ->{command_definitions} with as value an array for the contents of
# the command_definitions.  Each command_definition value has again
# the content of a command_definition and a key ->{command_tests}.
#
# Each element in the result receives a key ->{context_path} that is
# unique and identifies the path from the root to the element.
#

our @ISA = ("Heterarch::Test::Output");


#
# Create the infrastructure for keeping module test results.
#

sub ex_mo_prepare
{
    my $self = shift;

    # create an output entry for the module

    my $execution_context = $self->{execution_context};

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    if (not $global_test_report->{selected}->{$module_name})
    {
	my $module_counter = $execution_context->get_module_definition_counter();

	my $context_path = $execution_context->get_context_path();;

	if ($option_verbose)
	{
	    print $global_fd_output "$0: Preparing $context_path\n";
	}

	$global_test_report->{selected}->{$module_name}
	    = {
	       command_definitions => [],
	       comment => $module_definition->{comment},
	       context_path => $context_path,
	       count => $module_counter,
	       description => $module_definition->{description},
	       documentation => $module_definition->{documentation},
	       harnessing => {
			      preparation => $module_definition->{harnessing}->{preparation}->{description},
			      reparation => $module_definition->{harnessing}->{reparation}->{description},
			     },
	       name => $module_name,
	      };
    }
    else
    {
	die "$0: *** Error: module_name $module_name is defined twice.";
    }
}


#
# Adds the current test description to the summary, constructs a
# structure to keep results.
#

sub ex_ct_run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # get the current module summary

    my $selected_module = $global_test_report->{selected}->{$module_name};

    # get the current test summary

    my $module_command_definitions = $selected_module->{command_definitions};

    my $command_definition_counter = $execution_context->get_command_definition_counter_per_module();

    my $selected_command_definition = $module_command_definitions->[$command_definition_counter - 1];

    # get the current command test

    if (not exists $selected_command_definition->{command_tests})
    {
	$selected_command_definition->{command_tests} = [];
    }

    my $selected_test_definitions = $selected_command_definition->{command_tests};

    my $test_definition_counter = $execution_context->get_command_test_counter_per_command_definition();

    # if (not $selected_test_definitions->[$test_definition_counter])
    # {
    # 	$selected_test_definitions->[$test_definition_counter] = {};
    # }

    # just clone the current command test and add to the result

    use Clone 'clone';

    my $cloned_command_test = clone($command_test);

    # add the context_path

    my $context_path = $execution_context->get_context_path();;

    if ($option_verbose)
    {
	print $global_fd_output "$0: Preparing $context_path\n";
    }

    $cloned_command_test->{context_path} = $context_path;

    push @$selected_test_definitions, $cloned_command_test;

    # my $selected_test_definition = $selected_test_definitions->[$test_definition_counter];

    # # add the current test description to the summary

    # $selected_test_definition->{description} = $command_test->{description};

    # always succeeds

    my $test_result
	= {
	   after_match => "",
	   before_match => "",
	   error => "",
	   expected => "",
	   matched_pattern_position => "",
	   successfully_matching_string => "",
	  };

    return $test_result;
}


#
# Adds the current command definition to the summary, constructs a
# structure to keep results.
#

sub ex_cd_start
{
    my $self = shift;

    # get the execution context

    my $execution_context = $self->{execution_context};

    # create an output entry for the module

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # create an output entry for the current command definition

    my $selected_module = $global_test_report->{selected}->{$module_name};

    my $selected_command_definitions = $selected_module->{command_definitions};

    my $command_definition = $execution_context->get_command_definition();

    # just clone the current command_definition

    use Clone 'clone';

#     push @$selected_command_definitions, { description => $command_definition->{description}, tests => [], };

    my $cloned_command_definition = clone($command_definition);

    delete $cloned_command_definition->{command_tests};

    # add the context_path

    my $context_path = $execution_context->get_context_path();;

    if ($option_verbose)
    {
	print $global_fd_output "$0: Preparing $context_path\n";
    }

    $cloned_command_definition->{context_path} = $context_path;

    # add to the result

    push @$selected_command_definitions, $cloned_command_definition;
}


sub ex_terminate
{
    my $self = shift;

    my $fd_output = shift;

    my $test_module_library_contents = shift;

    my $selected_output_levels = $Heterarch::Test::Element::selected_output_levels;

    my $extension = join '-', sort keys %$selected_output_levels;

    my $output_directory = "/tmp/test_report_$global_config->{package}->{name}";

    my $created;

    if ( !-d $output_directory )
    {
	use File::Path qw( make_path );

	$created = make_path($output_directory);
    }
    else
    {
	$created = "exists";
    }

    if ($created)
    {
	my $output_filename = "test_report_$global_config->{package}->{name}_$extension";

	my $output_pathname = "$output_directory/$output_filename";

	$self->process($output_pathname, $test_module_library_contents, $global_test_report);

	# my $testing = 1;

	# if ($testing)
	# {
	# 	my $output_filename = "/tmp/test_report_$global_config->{package}->{name}";

	# 	$self->process($output_filename, $test_module_library_contents, $global_test_report);
	# }
    }
    else
    {
	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => "error creating the output_directory ($created)",
		  error => "this test was tagged with the error flag",
		  module_name => "END",
		  subdescription => "error creating the output_directory ($created)",
		 },
		);
    }
}


package Heterarch::Test::Output::Formatter::HTMLTable;

# the Formatter:: HTMLTable package converts the test specifications
# to HTML tables.


our @ISA = ("Heterarch::Test::Output::Formatter");


#
# sub start
#
# Incomplete.
#

sub ex_cd_start
{
    my $self = shift;

    my $execution_context = $self->{execution_context};

    my $module_definition = $execution_context->get_module_definition();

    my $command_definition = $execution_context->get_command_definition();

    my $fd_output = $self->{fd_output};

    # we have to either instantiate an object that produces output ...

    if ($command_definition->{class})
    {
	# instantiate the object

	my $class = $command_definition->{class};

	my $filename = $class . ".pm";

	$filename =~ s(::)(/)g;

	# require $filename;

	# $self->{command_object} = eval "$class->new()";
    }

    # ... or run perl code that produces output

    elsif (ref $command_definition->{command} eq 'CODE')
    {
	# code is already instantiated, nothing to do here
    }

    # ... or run a command that produces output

    else
    {
	# start the command and connect with its I/O channels

	# my ($exp, $test_startup) = $command_definition->spawn_new($execution_context, $fd_output);

	# remember to spawn a new command

	my $spawn_new = not $command_definition->{recycle};

	# retrieve the shell command and its arguments

	my ($command, $arguments) = $command_definition->parse_command_line();

	# if the command can be executed

	if (defined $command)
	{
	    if ($spawn_new)
	    {
	    }
	    else
	    {
		# print $fd_output "*** Recycling $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";
	    }
	}
    }
}


package Heterarch::Test::Output::Formatter::Latex;

# The Heterarch::Test::Output::Formatter::Latex package converts the test specifications
# to a Latex document.


our @ISA = ("Heterarch::Test::Output::Formatter");


our $output_file;


sub _output_latex
{
    my $outputfile = shift;

    my $contents = shift;

    $contents =~ s/_/\\_/g;
    $contents =~ s/&/\\&/g;

    print $outputfile $contents;
}


sub _output_latex_table
{
    my $outputfile = shift;

    my $contents = shift;

    my $prompt = shift;

    _output_latex_environment_prompt
	(
	 $output_file,
	 {
	  content_type => "Verbatim",
	  prompt => $prompt,
	  suffix => "\n\n",
	 },
	);

    _output_latex($output_file, '\begin{longtable}{p{13cm}}' . "\n");

    _output_latex($output_file, '\hline' . "\n");

    _output_latex_environment_prompt
	(
	 $output_file,
	 {
	  content_type => "Verbatim",
	  content => $contents,
	 }
	);

    _output_latex($output_file, '\\\\' . "\n");

    _output_latex($output_file, '\hline' . "\n");

    _output_latex($output_file, '\end{longtable}' . "\n");

}


sub _output_latex_environment_prompt
{
    my $outputfile = shift;

    my $content_options = shift;

    my $content_line_limit = $content_options->{content_line_limit};
    my $content_type = $content_options->{content_type};
    my $content_type_options = $content_options->{content_type_options} || "";
    my $content = $content_options->{content} || "";
    my $prompt = $content_options->{prompt} || "";
    my $suffix = $content_options->{suffix} || "";

    # if there is content

    if (defined $content)
    {
	# cut the content at the content limit

	if ($content_line_limit)
	{
	    my $line_count = $content =~ tr/\n//;

	    if ($line_count > $content_line_limit)
	    {
		my $first_lines = join "\n", ( split /\n/, $content )[0 .. $content_line_limit];

		$content = $first_lines . "\n ... < cut at $content_line_limit lines, more follows > ...\n";
	    }
	}

	# output the prompt

	_output_latex($output_file, $prompt);

	# output the content enclosed with the begin and end markers

	if ($content_type)
	{
	    _output_latex($output_file, '\begin{' . $content_type . "}$content_type_options\n");
	}

	_output_latex($output_file, $content);

	if ($content !~ /\n$/)
	{
	    _output_latex($output_file, "\n");
	}

	if ($content_type)
	{
	    _output_latex($output_file, '\end{' . $content_type . "}\n");
	}
    }

    # output the suffix

    _output_latex($output_file, $suffix);
}


sub _output_latex_environment_minipage
{
    my $outputfile = shift;

    my $content_options = shift;

    my $content_line_limit = $content_options->{content_line_limit};
    my $content_type = $content_options->{content_type};
    my $content_type_embedding = $content_options->{content_type_embedding} || "";
    my $content_type_options = $content_options->{content_type_options} || "";
    my $content = $content_options->{content};
    my $prompt = $content_options->{prompt} || "";
    my $prompt_type = $content_options->{prompt_type};
    my $suffix = $content_options->{suffix} || "";

    # if there is content

    if (defined $content)
    {
	# cut the content at the content limit

	if ($content_line_limit)
	{
	    my $line_count = $content =~ tr/\n//;

	    if ($line_count > $content_line_limit)
	    {
		my $first_lines = join "\n", ( split /\n/, $content )[0 .. $content_line_limit];

		$content = $first_lines . "\n ... < cut at $content_line_limit lines, more follows > ...\n";
	    }
	}

	# output the content begin marker

	if ($content_type)
	{
	    print $output_file '\vspace{3ex}
\begin{' . $content_type . "}$content_type_options\n";
	}

	# output the embedding start

	if ($content_type_embedding)
	{
	    print $outputfile "\\$content_type_embedding\{";
	}

	# output the prompt

	_output_latex_prompt($output_file, $prompt_type, $prompt, "", "");

	# output the content

	_output_latex($output_file, $content);

	if ($content !~ /\n$/)
	{
	    _output_latex($output_file, "\n");
	}

	# output the embedding end

	if ($content_type_embedding)
	{
	    print $outputfile "\}\n";
	}

	# output the content end marker

	if ($content_type)
	{
	    print $output_file '\end{' . $content_type . "}\n" . '\vspace{3ex}
';
	}
    }

    # output the suffix

    _output_latex($output_file, $suffix);
}


sub _output_latex_figure_generate_insert
{
    my $figure = shift;

    my $figure_class = exists $figure->{class} ? $figure->{class} : "simple";

    my $output_filename = shift;

    my $command_test = shift;

    my $figure_references = shift;

    my $read = shift;

    my $figure_class_2_package
	= {
	   hh_gates_A_B => "Heterarch::Test::Output::Formatter::Figure::HHGatesAB",
	   hh_gates_alpha_beta => "Heterarch::Test::Output::Formatter::Figure::HHGatesAlphaBeta",
	   hh_gates_internal => "Heterarch::Test::Output::Formatter::Figure::HHGatesInternal",
	   hh_gates_steady_state_tau => "Heterarch::Test::Output::Formatter::Figure::HHGatesSteadyStateTau",
	   simple => "Heterarch::Test::Output::Formatter::Figure::Simple",
	  };

    my $figure_package = $figure_class_2_package->{$figure_class};

    # create the figure object, link it with the generated references

    my $figure_object = $figure_package->new($figure, $output_filename, $command_test, $figure_references, $read);

    # generate its reference

    my $label_error = $figure_object->generate_label('latex');

    # render the graph

    my $render_error = $figure_object->render();

    # insert the figure filename in the latex file

    my $insert_error = $figure_object->insert($figure);

    if ($label_error or $render_error or $insert_error)
    {
	#! note that this does not generate a label for referencing

	_output_latex_environment_minipage
	    (
	     $output_file,
	     {
	      content => "Please install GD::Graph to render figures",
	      content_type => "minipage",
	      content_type_options => '{14cm}',
	      content_type_embedding => "small",
	      prompt => "ERROR\\::",
	      prompt_type => 'textbf',
	      suffix => "\n\n",
	     },
	    );
    }
}


sub _output_latex_figure_references_insert
{
    my $figure_references = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    # my $fr_0 = $ss->{fr_0};

    # my $fr_1 = $ss->{fr_1};

    if ($cd_1)
    {
	print $output_file '\item [$\bullet$]';
    }

    if (scalar @$figure_references eq 1)
    {
	print $output_file 'See figure~\ref{' . $figure_references->[0] . "}";
    }
    else
    {
	print $output_file 'See figures';

	while (my $figure_reference = shift @$figure_references)
	{
	    if (scalar @$figure_references eq 0)
	    {
		print $output_file '~\ref{' . $figure_reference . '}';
	    }
	    elsif (scalar @$figure_references eq 1)
	    {
		print $output_file '~\ref{' . $figure_reference . '} and';
	    }
	    else
	    {
		print $output_file '~\ref{' . $figure_reference . '},';
	    }
	}
    }

    print $output_file ".\n\n";
}


sub _output_latex_module_comments
{
    my $module_definition = shift;

    _output_latex_environment_minipage
	(
	 $output_file,
	 {
	  content => $module_definition->{comment},
	  content_type => "minipage",
	  content_type_options => '{14cm}',
	  content_type_embedding => "small",
	  prompt => "NOTE\\::",
	  prompt_type => 'textbf',
	  suffix => "\n\n",
	 },
	);
}


sub _output_latex_module_documentation
{
    my $module_definition_documentation = shift;

    if ($module_definition_documentation)
    {
	_output_latex($output_file, "$module_definition_documentation->{purpose}\n\n");

	_output_latex($output_file, "$module_definition_documentation->{explanation}\n\n");

	# _output_latex($output_file, "Test commands follow.\n\n");
    }
    else
    {
	_output_latex($output_file, "\n\n");
    }
}


sub _output_latex_module_filename_insert
{
    my $module_definition = shift;

    my $module_definition_documentation = shift;

    my $ss = shift;

    my $cd_0 = $ss->{cd_0};

    my $cd_1 = $ss->{cd_1};

    if ($cd_0)
    {
	_output_latex($output_file, 'File ');

	_output_latex_prompt($output_file, "textit", $module_definition->{name}, "", "");

	if ($module_definition_documentation)
	{
	    _output_latex($output_file, ':  ');
	}
	else
	{
	    _output_latex($output_file, '.');
	}
    }
    elsif ($cd_1)
    {
	_output_latex($output_file, 'The file ');

	_output_latex_prompt($output_file, "textit", $module_definition->{name}, "", "");

	_output_latex($output_file, " defines the test that is explained in this section.\n\n");
    }
    else
    {
	_output_latex($output_file, 'The file ');

	_output_latex_prompt($output_file, "textit", $module_definition->{name}, "", "");

	_output_latex($output_file, " defines the tests that are explained in this section.\n\n");
    }
}


sub _output_latex_module_harnessing
{
    my $module_definition = shift;

    my $ss = shift;

    my $cd_0 = $ss->{cd_0};

    if ($cd_0)
    {
	my $harnessing = $module_definition->{harnessing};

	if ($harnessing->{preparation})
	{
	    _output_latex($output_file, '\begin{' . "itemize" . "}\n");

	    _output_latex($output_file, '\item ');

	    _output_latex_prompt($output_file, "textit", $module_definition->{harnessing}->{preparation}, "Preparation: ", "\n");

	    _output_latex($output_file, '\item ');

	    _output_latex_prompt($output_file, "textit", $module_definition->{harnessing}->{reparation}, "Reparation: ", "\n");

	    _output_latex($output_file, '\end{' . "itemize" . "}\n");
	}
    }
}


sub _output_latex_postamble
{
    my $postamble
	= '\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
';

#    $output_file = IO::File->new(">>$output_filename");

    print $output_file $postamble;
}


sub _output_latex_preamble
{
    my $output_filename = shift;

    my $html_introduction = shift;

    my $main_figures_directory = "$output_filename/figures";

    {
	use File::Basename qw( fileparse );
	use File::Path qw( make_path );
	use File::Spec;

	my $created = make_path($main_figures_directory);

	use File::Copy;

	my $logo_source_filename = "$ENV{HOME}/projects/neurocampus/source/snapshots/master/invoices/inv-draft-only/figures/ns-main-logo-dark2.jpg";

	copy($logo_source_filename, "$main_figures_directory")
	    or die "Copy of $logo_source_filename failed: $!";
    }

    $output_file = IO::File->new(">$output_filename.tex");

    my $title_paragraphs = _output_latex_preamble_construct($html_introduction);

    my $preamble1
	= '\documentclass[10pt,a4paper,landscape]{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage[colorlinks=true]{hyperref}
% \usepackage[dvips]{epsfig}
\usepackage{enumitem} % [noitemsep,nolistsep] compact itemize/enumerate etc.
\usepackage{graphicx}
\usepackage{longtable}
% \usepackage[margin=2cm]{geometry}
\usepackage{subcaption}
\usepackage{url}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{relsize}

\usepackage{footmisc}	% ADC: Added footnote referencing capacity for text editing comments

% Typeface
\usepackage[condensed,math]{iwona}
\usepackage[T1]{fontenc}

% A4 portrait

% \setlength{\textwidth}{15.7cm}
% \setlength{\textheight}{22cm}

% \setlength{\topmargin}{0cm}
% \setlength{\headheight}{1cm}
% \setlength{\headsep}{0.5cm}
% \setlength{\topskip}{0cm}

% A4 landscape

\setlength{\textwidth}{25cm}
\setlength{\textheight}{15cm}

\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\setlength{\headsep}{0cm}
\setlength{\topskip}{0cm}

\setlength{\oddsidemargin}{0pt}

';

    print $output_file $preamble1;

    my $use_title_page = "";

    if ($use_title_page)
    {
	_output_latex_preamble_configure_title_page($title_paragraphs);
    }

    my $preamble2
	= '
\begin{document}

\begin{center}
   \includegraphics[scale=0.5]{' . $main_figures_directory . '/ns-main-logo-dark2.jpg}
%   \caption{{\bf A Dummy Figure:} Example of \LaTeX\,\,\,code to incorporate a figure into documentation.}
  \label{fig:logo}
\end{center}
\vspace{-10ex}

';

    if ($use_title_page)
    {
	$preamble2 .= '
       \maketitle

';
    }

    print $output_file $preamble2;

    if (not $use_title_page)
    {
	_output_latex($output_file, '\section*{\center \Huge ' . $title_paragraphs->{title} . "}\n\n");

	_output_latex($output_file, '\vspace{-6ex}' . "\n\n");

	_output_latex($output_file, '\section*{\center \scriptsize ' . "Automatically generated draft document" . "}\n\n");

	_output_latex($output_file, '\vspace{-6ex}' . "\n\n");

	_output_latex($output_file, '\section*{\center \small \textbf ' . $title_paragraphs->{author} . "}\n\n");

	_output_latex($output_file, '\vspace{-6ex}' . "\n\n");

	use POSIX qw(strftime);

	# my $now_string = strftime("%a %b %e %H:%M:%S %Y", localtime());

	my $now_string = strftime("%a %b %e, %Y", localtime());

	my ( $day, $month_number, $year ) = ( localtime ) [3,4,5];

	$year += 1900;

	my $month = (
		     qw/ January   February  March
			 April     May       June
			 July      August    September
			 October   November  December  /
		    ) [$month_number];

	$now_string = "$day $month, $year";

	_output_latex($output_file, '\section*{\center \small \textbf ' . $now_string . "}\n\n");
    }

    _output_latex_preamble_abstract($title_paragraphs);

    _output_latex_preamble_summary($title_paragraphs);
}


sub _output_latex_preamble_abstract
{
    my $title_paragraphs = shift;

}


sub _output_latex_preamble_construct
{
    my $html_introduction_original = shift;

    my $html_introduction = $html_introduction_original;

    # extract email address

    $html_introduction =~ m(<address>(.*)</address>)gs;

    my $email_anchored = $1;

    my $author = $email_anchored || "";

    $author =~ m(<a.*?>(.*)</a>)gs;

    $author = $1 || "";

    my $thanks = $email_anchored || "";

    $thanks =~ m("mailto:(.*)")gs;

    $thanks = $1 || "";

    # remove trailing part

    $html_introduction =~ s(<address>(.*))()gs;

    # extract title

    $html_introduction =~ s(<h1>(.*)</h1>)()gs;

    my $title = $1 || "";

    # enumeration tags

    $html_introduction =~ s(<ul>)(\\begin{itemize}\n  \\setlength\\itemsep{-0.35em}\n)gs;

    $html_introduction =~ s(</ul>)(\\end{itemize})gs;

    $html_introduction =~ s(<li>)(\\item )gs;

    # remove irrelevant html tags

    $html_introduction =~ s(<p/?>)()gs;

    $html_introduction =~ s(<hr/?>)()gs;

    # split in paragraphs

    my $paragraphs = [ split "\n\n", $html_introduction, ];

    # construct and return result

    my $result
	= {
	   author => $author,
	   email_anchored => $email_anchored,
	   original_contents => $html_introduction_original,
	   paragraphs => $paragraphs,
	   thanks => $thanks,
	   title => $title,
	  };

    return $result
}


sub _output_latex_preamble_summary
{
    my $title_paragraphs = shift;

    my $paragraphs = $title_paragraphs->{paragraphs};

    if (scalar @$paragraphs)
    {
	# output the description as a section title

	_output_latex($output_file, '\section*{\center ' . "Summary" . "}\n\n");

	# write paragraphs

	foreach my $paragraph (@$paragraphs)
	{
	    _output_latex($output_file, "$paragraph\n\n");
	}
    }
}


sub _output_latex_preamble_configure_title_page
{
    my $title_paragraphs = shift;

    # write title

    _output_latex($output_file, '\title{' . $title_paragraphs->{title} . "}\n\n");

    _output_latex($output_file, '\date{' . localtime() . "}\n\n");

    _output_latex($output_file, '\author{' . $title_paragraphs->{author} . "}\n\n");

}


sub _output_latex_command_definition_command_arguments
{
    my $command_definition = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    my $ct_1 = $ss->{ct_1};

    # retrieve the shell command and its arguments

    my ($command, $arguments) = $command_definition->parse_command_line();

    my $command_string = join ' ', $command, @$arguments;

    if ($cd_1)
    {
	print $output_file '\item [$\bullet$]';
    }

    if ($ct_1)
    {
	_output_latex($output_file, 'The test is started with the system shell command: ');
    }
    else
    {
	_output_latex($output_file, 'The tests are started with the system shell command: ');
    }

    _output_latex_prompt($output_file, "textbf", $command_string, "", "\n\n");
}


sub _output_latex_command_definition_comments
{
    my $command_definition = shift;

    my $ss = shift;

    my $cd_1_comment = $ss->{cd_1_comment};

    if ($cd_1_comment)
    {
	print $output_file '\item [$\bullet$]';

	_output_latex_environment_minipage
	    (
	     $output_file,
	     {
	      content => $command_definition->{comment},
	      content_type => "minipage",
	      content_type_options => '{14cm}',
	      content_type_embedding => "small",
	      prompt => "NOTE\\::",
	      prompt_type => 'textbf',
	      suffix => "\n\n",
	     },
	    );
    }
}


sub _output_latex_command_definition_description
{
    my $command_definition = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    my $ct_1 = $ss->{ct_1};

    my $description = $command_definition->{description};

    my $command_tests = $command_definition->{command_tests};

    if ($cd_1)
    {
	print $output_file '\item [$\bullet$]';

	_output_latex($output_file, "The following test is described as: $description\n");
    }
    else
    {
	if ($ct_1)
	{
	    my $subdescription = $command_tests->[0]->{description};

	    $description .= ": $subdescription";
	}

	_output_latex($output_file, '\subsection{' . ucfirst $description . "}\n\n");
    }
}


sub _output_latex_command_definition_harnessing
{
    my $command_definition = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    my $harnessing = $command_definition->{harnessing};

    if ($harnessing->{preparation})
    {
	if ($cd_1)
	{
	    print $output_file '\item [$\bullet$]';
	}

	_output_latex($output_file, '\begin{' . "itemize" . "}\n");

	_output_latex($output_file, '\item ');

	_output_latex_prompt($output_file, "textit", $command_definition->{harnessing}->{preparation}, "Preparation: ", "\n");

	_output_latex($output_file, '\item ');

	_output_latex_prompt($output_file, "textit", $command_definition->{harnessing}->{reparation}, "Reparation: ", "\n");

	_output_latex($output_file, '\end{' . "itemize" . "}\n");
    }
}


sub _output_latex_command_test_comments
{
    my $command_test = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    if ($command_test->{comments})
    {
	if ($cd_1)
	{
	    print $output_file '\item [$\bullet$]';
	}

	_output_latex_environment_minipage
	    (
	     $output_file,
	     {
	      content => $command_test->{comment},
	      content_type => "minipage",
	      content_type_options => '{14cm}',
	      content_type_embedding => "small",
	      prompt => "NOTE\\::",
	      prompt_type => 'textbf',
	      suffix => "\n\n",
	     },
	    );
    }
}


sub _output_latex_command_test_description
{
    my $command_test = shift;

    my $ss = shift;

    my $ct_1 = $ss->{ct_1};

    my $description = $command_test->{description};

    if ($ct_1)
    {
	# _output_latex($output_file, "This test is described as: $description\n\n");
    }
    else
    {
	_output_latex($output_file, '\subsubsection{' . ucfirst $description . "}\n\n");
    }
}


sub _output_latex_command_test_disabled
{
    my $command_test = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    #! this seems to be wrong, cannot have the disabled
    #! clause of each command test in a isolated bullet,
    #! maybe this also needs a $ct_1?

    if ($cd_1
	and $command_test->{disabled})
    {
	print $output_file '\item [$\bullet$]';

	_output_latex_prompt($output_file, "textbf", $command_test->{disabled}, "note that this test was disabled: \n", "\n\n");
    }
}


sub _output_latex_command_test_read
{
    my $command_test = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    my $read = $command_test->{read} || "";

    if ($read)
    {
	if ($cd_1)
	{
	    print $output_file '\item [$\bullet$]';
	}

	_output_latex_environment_prompt
	    (
	     $output_file,
	     {
	      content => $read,
	      content_line_limit => $option_output_content_line_limit,,
	      content_type => "Verbatim",
	      content_type_options => '[fontsize=\relsize{-2}]',
	      prompt => "Expected application output:\n",
	      suffix => "\n\n",
	     },
	    );
    }
}


sub _output_latex_command_test_write
{
    my $command_test = shift;

    my $ss = shift;

    my $cd_1 = $ss->{cd_1};

    my $write = $command_test->{write} || "";

    if ($write)
    {
	if ($cd_1)
	{
	    print $output_file '\item [$\bullet$]';
	}

	_output_latex_environment_prompt
	    (
	     $output_file,
	     {
	      content => $write,
	      content_line_limit => $option_output_content_line_limit,,
	      content_type => "Verbatim",
	      content_type_options => '[fontsize=\relsize{-2}]',
	      prompt => "The input to the application is:\n",
	      suffix => "\n\n",
	     },
	    );
    }
}


sub _output_latex_process
{
    my $output_filename = shift;

    my $test_report = shift;

    my $module_definitions = $test_report->{selected};

    my $ss = Heterarch::Test::Output::StructureSummary->new();

    foreach my $module_definition_key (sort
				       {
					   my $selected_a = $a;
					   my $selected_b = $b;

					   my $counter_a = $module_definitions->{$selected_a}->{count};
					   my $counter_b = $module_definitions->{$selected_b}->{count};

					   $counter_a <=> $counter_b;
				       }
				       keys %$module_definitions)
    {
	my $module_definition = $module_definitions->{$module_definition_key};

	my $module_definition_description = $module_definition->{description};

	my $module_definition_documentation = $module_definition->{documentation} || "";

	my $command_definitions = $module_definition->{command_definitions};

	# output the description as a section title

	_output_latex($output_file, '\section{' . ucfirst $module_definition_description . "}\n\n");

	# create indexes into the styling table

	$ss->ss_command_definitions($command_definitions);

	# output the filename

	_output_latex_module_filename_insert($module_definition, $module_definition_documentation, $ss);

	# output the documentation and explanation

	_output_latex_module_documentation($module_definition_documentation);

	# output the preparation and reparation

	_output_latex_module_harnessing($module_definition, $ss);

	# output comments / notes

	_output_latex_module_comments($module_definition);

	# output the command definitions

	foreach my $command_definition (@$command_definitions)
	{
	    # create indexes into the styling table

	    my $command_tests = $command_definition->{command_tests};

	    $ss->ss_command_tests($command_tests);

	    if ($ss->{cd_1})
	    {
		print $output_file '\begin{enumerate}[noitemsep,nolistsep]' . "\n";
	    }

	    # output the command_definition description

	    _output_latex_command_definition_description($command_definition, $ss);

	    # output the command and its arguments

	    _output_latex_command_definition_command_arguments($command_definition, $ss);

	    # output the command comments

	    _output_latex_command_definition_comments($command_definition, $ss);

	    # output the preparation and reparation

	    _output_latex_command_definition_harnessing($command_definition, $ss);

	    # loop over all the command tests

	    foreach my $command_test (@$command_tests)
	    {
		# output the disabled clause

		_output_latex_command_test_disabled($command_test, $ss);

		# output the description clause

		_output_latex_command_test_description($command_test, $ss);

		# output the write clause

		_output_latex_command_test_write($command_test, $ss);

		# output the read clause

		_output_latex_command_test_read($command_test, $ss);

		# if figures should be generated

		if ($option_output_figures)
		{
		    # loop over all the figures for this command test

		    my $figures = $command_test->{figures};

		    my $figure_references = [];

		    my $read = $command_test->{read} || "";

		    foreach my $figure (@$figures)
		    {
			_output_latex_figure_generate_insert($figure, $output_filename,  $command_test, $figure_references, $read);
		    }

		    if (scalar @$figure_references)
		    {
			$ss->ss_figure_references($figure_references);

			_output_latex_figure_references_insert($figure_references, $ss);
		    }
		}

		# output the comments clause

		_output_latex_command_test_comments($command_test, $ss);
	    }

	    if ($ss->{cd_1})
	    {
		print $output_file '\end{enumerate}' . "\n";
	    }
	}
    }
}


sub _output_latex_prompt
{
    my $outputfile = shift;

    my $content_type = shift;

    my $content = shift;

    my $prompt = shift;

    my $suffix = shift;

    if (defined $content)
    {
	_output_latex($output_file, $prompt);

	if ($content_type)
	{
	    print $output_file '\\' . $content_type . '{';
	}

	_output_latex($output_file, " $content ");

	if ($content_type)
	{
	    print $output_file "}";
	}
    }

    _output_latex($output_file, $suffix);
}


sub process
{
    my $self = shift;

    my $output_filename = shift;

    my $test_module_library_contents = shift;

    my $global_test_report = shift;

    _output_latex_preamble
	(
	 $output_filename,
	 $test_module_library_contents->{html_introduction},
	);

    _output_latex_process($output_filename, $global_test_report);

    _output_latex_postamble();
}


package Heterarch::Test::Output::Formatter::Figure;


sub generate_label
{
    my $self = shift;

    my $type = shift;

    # create the label for this figure

    my $figure_definition = $self->{figure_definition};

    my $context_path = $self->{context_path};

    #! this may be latex specific

    if ($type eq 'latex')
    {
	my $figure_label = "fig:$context_path-$figure_definition->{name}";

	# add it to the list of references

	my $figure_references = $self->{figure_references};

	push @$figure_references, $figure_label;

	# set figure label

	$self->{figure_label} = $figure_label;

	# return: no error

	return undef;
    }
    else
    {
	return  \ "$0: only latex labels have been implemented.";
    }
}


sub insert
{
    my $self = shift;

    my $figure_definition = shift;

    my $full_caption = $figure_definition->{caption}->{full};

    my $short_caption = $figure_definition->{caption}->{short};

    my $filenames = $self->{filenames};

    # insert the figure filename in the latex file

    $self->insert_figure_environment
	(
	 $output_file,
	 {
	  caption => [ $full_caption, ],
	  caption_short => [ $short_caption, ],
	  content_type_options => '[ht]',
	  includegraphics => $filenames,
	  label => $self->{figure_label},
	 },
	);

    # return result: no error

    return undef;
}


sub insert_figure_environment
{
    my $self = shift;

    my $outputfile = shift;

    my $content_options = shift;

    my $content_type_options = $content_options->{content_type_options} || "";
    my $includegraphics = $content_options->{includegraphics};
    my $caption = $content_options->{caption};
    my $caption_short = $content_options->{caption_short} || "";
    my $label = $content_options->{label};

# \begin{figure}
# \fbox{\includegraphics[width=\linewidth]{/tmp/abcdef-output_graph_render.pdf}}
# \end{figure}

# % \begin{figure}[ht]
# %   \includegraphics*[scale=0.1]{/tmp/abcdef-output_graph_render.pdf}
# % %  \resizebox{2cm}{!} {\includegraphics{/tmp/abcdef-output_graph_render.pdf}}
# %   \caption[Ten passive compartments voltage clamped]{\small Ten passive compartments clamped with command voltage of 0.1V using a perfect clamp object.}
# %   \label{fig:perfectclamp}
# % \end{figure}

    # if there is content

    if (defined $includegraphics)
    {
	# output the content begin marker

	print $output_file '\begin{figure}' . "$content_type_options\n";

# 	print $output_file '  \center'. "\n";

	my $width_divider = 1 / scalar @$includegraphics;

	my $includegraphics_options = "[width=$width_divider" . '\linewidth]';

	foreach my $includegraphic (@$includegraphics)
	{
	    print $output_file '  \includegraphics' . $includegraphics_options . "{$includegraphic}\n";
	}

	for (my $index = 0 ; $index < scalar @$caption ; $index++)
	{
# 	    print $output_file '  \begin{minipage}' . '{' . $width_divider . '\linewidth}' . "\n";

	    print $output_file '    \caption[' . $caption_short->[$index] . ']{\small \textbf{' . $caption->[$index] . '}}' . "\n";

# 	    print $output_file '  \end{minipage}' . "\n";
	}

	if ($label)
	{
	    print $output_file '  \label{'. $label . '}' . "\n";
	}

# \begin{figure}[ht]
#   \center
#   \includegraphics[scale=0.6]{figures/mstep.eps}
#   \caption[Staggered Time Grid]{\small \index{staggered
#       time grid} Mid step evaluation of membrane potential and
#     Hodgkin-Huxley equations.  To calculate the conductance at time
#     point 2, we need the membrane potential at time point 1.  To
#     calculate the membrane potential at time point 3, we need the
#     conductance at time point 2.  The membrane potential at time point
#     2 is never computed, neither the conductance at time point 3.}
#   \label{fig:midstep}
# \end{figure}

	# output the content end marker

	print $output_file '\end{figure}' . "\n\n";
    }

    # return result: no error

    return undef;
}


sub new
{
    my $package = shift;

    my $figure_definition = shift;

    my $filename_prefix = shift;

    my $command_test = shift;

    my $figure_references = shift;

    my $data_string = shift;

    my $context_path = $command_test->{context_path};

    $context_path =~ s(/)(___)g;
    $context_path =~ s(\.)(__)g;

    my $pathname_prefix = "$filename_prefix$context_path-$figure_definition->{name}";

    my $self
	= {
	   context_path => $context_path,
	   data_string => $data_string,
	   figure_definition => $figure_definition,
	   figure_references => $figure_references,
	   filename_prefix => $filename_prefix,
	   pathname_prefix => $pathname_prefix,
	  };

    bless $self, $package;

    return $self;
}


sub render_raw_data
{
    my $self = shift;

    my $output_filename = shift;

    my $data_string = shift;

    # create the data file

    my $figure_definition = $self->{figure_definition};

    my $pathname_prefix = $self->{pathname_prefix};

    my $data_filename = $pathname_prefix . "_output_graph_render_data";

    my $fh_data = IO::File->new("> $data_filename");

    if (not defined $fh_data)
    {
	return \ "$0: render_raw_data(): error opening result data file";
    }

    # write the data

    print $fh_data $data_string;;

    $fh_data->close();

    # create the figure_definition file

    my $figure_definition_filename = $pathname_prefix . "_output_graph_render_figure_definition.yml";

    YAML::DumpFile($figure_definition_filename, $figure_definition);

    # create the figure graph

    my $command = "data_2_figure --figure-filename '$figure_definition_filename' --input-data '$data_filename' --output-filename '$output_filename'";

    if ($option_verbose)
    {
	print $global_fd_output "$0: Executing '$command'\n";
    }

    system $command;

    if ($?)
    {
	return \ "$0: render_raw_data: '$command' failed";
    }
    else
    {
	return undef;
    }
}


sub render_array
{
    my $self = shift;

    my $output_filename = shift;

    my $array = shift;

    my $start = shift;

    my $end = shift;

    my $step = shift;

    # convert the array to raw_data

    my $raw_data = "";

    foreach my $entry (@$array)
    {
	$raw_data .= "$start $entry\n";

	$start += $step;
    }

    # render the raw data, result is the figure filename

    my $error = $self->render_raw_data($output_filename, $raw_data);

    if ($error)
    {
	return $error;
    }
    else
    {
	return $output_filename;
    }
}


package Heterarch::Test::Output::Formatter::Figure::HHGatesAB;


our @ISA = ("Heterarch::Test::Output::Formatter::Figure");


package Heterarch::Test::Output::Formatter::Figure::HHGatesAlphaBeta;


our @ISA = ("Heterarch::Test::Output::Formatter::Figure");


sub insert
{
    my $self = shift;

    my $figure_definition = shift;

    my $full_caption = $figure_definition->{caption}->{full};

    my $short_caption = $figure_definition->{caption}->{short};

    my $filenames = $self->{filenames};

    # insert the figure filename in the latex file

    $self->insert_figure_environment
	(
	 $output_file,
	 {
	  caption_main => $full_caption,
	  caption_main_short => $short_caption,
	  content_type_options => '[ht]',
	  includegraphics => $filenames,
	  label => $self->{figure_label},
	 },
	);
}


sub insert_figure_environment
{
    my $self = shift;

    my $outputfile = shift;

    my $content_options = shift;

    my $content_type_options = $content_options->{content_type_options} || "";
    my $includegraphics = $content_options->{includegraphics};
    my $caption = $content_options->{caption};
    my $caption_main = $content_options->{caption_main} || "";
    my $caption_main_short = $content_options->{caption_main_short} || "";
    my $caption_short = $content_options->{caption_short} || "";
    my $label = $content_options->{label};

    # if there is content

    if (defined $includegraphics)
    {
	# output the content begin marker

	print $output_file '\begin{figure}' . "$content_type_options\n";

	my $width_divider = 2 / scalar @$includegraphics;

	for (my $index = 0 ; $index < scalar @$includegraphics ; $index++)
	{
	    my $includegraphic = $includegraphics->[$index];

	    print $output_file '  \begin{subfigure}' . '{' . $width_divider . '\textwidth}' . "\n";

	    print $output_file '  \centering' . "\n";

	    my $includegraphics_options = "[width=.9" . '\linewidth]';

	    print $output_file '    \includegraphics' . $includegraphics_options . "{$includegraphic}\n";

# 	    print $output_file '    \caption[' . $caption_short->[$index] . ']{\small \textbf{' . $caption->[$index] . '}}' . "\n";

 	    print $output_file '  \end{subfigure}' . "\n";
	}

	if ($caption_main)
	{
	    print $output_file '    \caption[' . $caption_main_short . ']{\small \textbf{' . $caption_main . '}}' . "\n";
	}

	if ($label)
	{
	    print $output_file '  \label{'. $label . '}' . "\n";
	}

	# output the content end marker

	print $output_file '\end{figure}' . "\n\n";
    }

    # return result: no error

    return undef;
}


sub new
{
    my $self = shift;

    $self = $self->SUPER::new(@_);

    my $variables
	= [
	   {
	    name => "Activation",
	    regex_parser => '-?[0-9]+\.[-e0-9]+ (-?[0-9]+\.[-e0-9]+)',
	   },
	  ];

    $self->{figure_definition}->{variables} = $variables;

    return $self;
}


sub render
{
    my $self = shift;

    # convert the data string to a data structure

    use YAML;

    my $data_string = $self->{data_string};

    # remove object class references

    $data_string =~ s(!!.*?\n)(\n)g;

    # load all documents

    my $data_structured = [ Load($data_string), ];

    # split the data into its two components

    my $data_structured_forward = $data_structured->[0];

    my $data_structured_backward = $data_structured->[1];

    # render the values: forward kinetics

    my $data_a_forward = $data_structured_forward->{alpha};

    my $hi_forward = $data_structured_forward->{hi};

    my $pathname_prefix = $self->{pathname_prefix};

    my $output_filename_a_forward = "$pathname_prefix-a-forward-output_graph_render.png";

    my $figure_filename_a_forward = $self->render_array($output_filename_a_forward, $data_a_forward, $hi_forward->{start}, $hi_forward->{end}, $hi_forward->{step});

    if (ref $figure_filename_a_forward)
    {
	return $figure_filename_a_forward;
    }

    my $data_b_forward = $data_structured_forward->{beta};

    my $output_filename_b_forward = "$pathname_prefix-b-forward-output_graph_render.png";

    my $figure_filename_b_forward = $self->render_array($output_filename_b_forward, $data_b_forward, $hi_forward->{start}, $hi_forward->{end}, $hi_forward->{step});

    if (ref $figure_filename_b_forward)
    {
	return $figure_filename_b_forward;
    }

    # render the values: backward kinetics

    my $data_a_backward = $data_structured_backward->{alpha};

    my $hi_backward = $data_structured_backward->{hi};

    my $output_filename_a_backward = "$pathname_prefix-a-backward-output_graph_render.png";

    my $figure_filename_a_backward = $self->render_array($output_filename_a_backward, $data_a_backward, $hi_backward->{start}, $hi_backward->{end}, $hi_backward->{step});

    if (ref $figure_filename_a_backward)
    {
	return $figure_filename_a_backward;
    }

    my $data_b_backward = $data_structured_backward->{beta};

    my $output_filename_b_backward = "$pathname_prefix-b-backward-output_graph_render.png";

    my $figure_filename_b_backward = $self->render_array($output_filename_b_backward, $data_b_backward, $hi_backward->{start}, $hi_backward->{end}, $hi_backward->{step});

    if (ref $figure_filename_b_backward)
    {
	return $figure_filename_b_backward;
    }

    # set the filenames of the rendered graphs

    my $filenames = [ $figure_filename_a_forward, $figure_filename_b_forward, $figure_filename_a_backward, $figure_filename_b_backward, ];

    $self->{filenames} = $filenames;

    # return: no error

    return undef;
}


package Heterarch::Test::Output::Formatter::Figure::HHGatesInternal;


our @ISA = ("Heterarch::Test::Output::Formatter::Figure");


sub generate_label
{
    my $self = shift;

    return $self->SUPER::generate_label(@_);
}


sub insert
{
    my $self = shift;

    my $figure_definition = shift;

    my $full_caption = $figure_definition->{caption}->{full};

    my $short_caption = $figure_definition->{caption}->{short};

    my $filenames = $self->{filenames};

    # insert the figure filename in the latex file

    $self->insert_figure_environment
	(
	 $output_file,
	 {
	  caption => [
		      $figure_definition->{caption_A}->{full},
		      $figure_definition->{caption_B}->{full},
		     ],
	  caption_main => $figure_definition->{caption}->{full},
	  caption_main_short => $figure_definition->{caption}->{short},
	  caption_short => [
			    $figure_definition->{caption_A}->{short},
			    $figure_definition->{caption_B}->{short},
			   ],
	  content_type_options => '[ht]',
	  includegraphics => $filenames,
	  label => $self->{figure_label},
	 },
	);
}


sub insert_figure_environment
{
    my $self = shift;

    my $outputfile = shift;

    my $content_options = shift;

    my $content_type_options = $content_options->{content_type_options} || "";
    my $includegraphics = $content_options->{includegraphics};
    my $caption = $content_options->{caption};
    my $caption_main = $content_options->{caption_main} || "";
    my $caption_main_short = $content_options->{caption_main_short} || "";
    my $caption_short = $content_options->{caption_short} || "";
    my $label = $content_options->{label};

    # if there is content

    if (defined $includegraphics)
    {
	# output the content begin marker

	print $output_file '\begin{figure}' . "$content_type_options\n";

	my $width_divider = 1 / scalar @$includegraphics;

	for (my $index = 0 ; $index < scalar @$includegraphics ; $index++)
	{
	    my $includegraphic = $includegraphics->[$index];

	    print $output_file '  \begin{subfigure}' . '{' . $width_divider . '\textwidth}' . "\n";

	    print $output_file '  \centering' . "\n";

	    my $includegraphics_options = "[width=.9" . '\linewidth]';

	    print $output_file '    \includegraphics' . $includegraphics_options . "{$includegraphic}\n";

	    print $output_file '    \caption[' . $caption_short->[$index] . ']{\small \textbf{' . $caption->[$index] . '}}' . "\n";

 	    print $output_file '  \end{subfigure}' . "\n";
	}

	if ($caption_main)
	{
	    print $output_file '    \caption[' . $caption_main_short . ']{\small \textbf{' . $caption_main . '}}' . "\n";
	}

	if ($label)
	{
	    print $output_file '  \label{'. $label . '}' . "\n";
	}

	# output the content end marker

	print $output_file '\end{figure}' . "\n\n";
    }

    # return result: no error

    return undef;
}


sub new
{
    my $self = shift;

    $self = $self->SUPER::new(@_);

    my $variables
	= [
	   {
	    name => "Activation",
	    regex_parser => '-?[0-9]+\.[-e0-9]+ (-?[0-9]+\.[-e0-9]+)',
	   },
	  ];

    $self->{figure_definition}->{variables} = $variables;

    return $self;
}


sub render
{
    my $self = shift;

    # convert the data string to a data structure

    use YAML;

    my $data_string = "---
$self->{data_string}";

    # remove object class references

    $data_string =~ s(!!.*?\n)();

    my $data_structured = Load($data_string);

    # split the data into its two components

    my $data_a = $data_structured->{A};

    my $hi = $data_structured->{hi};

    my $pathname_prefix = $self->{pathname_prefix};

    my $output_filename_a = "$pathname_prefix-a-output_graph_render.png";

    my $figure_filename_a = $self->render_array($output_filename_a, $data_a, $hi->{start}, $hi->{end}, $hi->{step});

    if (ref $figure_filename_a)
    {
	return $figure_filename_a;
    }

    my $data_b = $data_structured->{B};

    my $output_filename_b = "$pathname_prefix-b-output_graph_render.png";

    my $figure_filename_b = $self->render_array($output_filename_b, $data_b, $hi->{start}, $hi->{end}, $hi->{step});

    if (ref $figure_filename_b)
    {
	return $figure_filename_b;
    }

    # set the filenames of the rendered graphs

    my $filenames = [ $figure_filename_a, $figure_filename_b, ];

    $self->{filenames} = $filenames;

    # return: no error

    return undef;
}


package Heterarch::Test::Output::Formatter::Figure::HHGatesSteadyStateTau;


our @ISA = ("Heterarch::Test::Output::Formatter::Figure");


package Heterarch::Test::Output::Formatter::Figure::Simple;


our @ISA = ("Heterarch::Test::Output::Formatter::Figure");


sub generate_label
{
    my $self = shift;

    return $self->SUPER::generate_label(@_);
}


sub new
{
    my $self = shift;

    return $self->SUPER::new(@_);
}


sub render
{
    my $self = shift;

    my $pathname_prefix = $self->{pathname_prefix};

    my $output_filename = "$pathname_prefix-output_graph_render.png";

    my $error = $self->SUPER::render_raw_data($output_filename, $self->{data_string});

    if ($error)
    {
	return $error;
    }
    else
    {
	# set the filenames of the rendered graphs

	my $filenames = [ $output_filename, ];

	$self->{filenames} = $filenames;

	# return: no error

	return undef;
    }
}


package Heterarch::Test::Output::Formatter::PDF;

# The Heterarch::Test::Output::Formatter::Latex package converts the test specifications
# to a Latex document.


our @ISA = ("Heterarch::Test::Output::Formatter::Latex");


sub _output_pdf_process
{
    use File::Basename qw( fileparse );
    use File::Path qw( make_path );
    use File::Spec;

    my $output_filename = shift;

    my ( $logfile, $directory ) = fileparse($output_filename);

    my $command = "cd '$directory' && pdflatex '$output_filename' && pdflatex '$output_filename'";

    system $command;
}


sub process
{
    my $self = shift;

    # my $result = Heterarch::Test::Output::Formatter::PDF->SUPER::process(@_);

    my $output_filename = shift;

    my $test_module_library_contents = shift;

    my $global_test_report = shift;

    my $result
	= $self->SUPER::process
	(
	 $output_filename,
	 $test_module_library_contents,
	 $global_test_report
	);

    _output_pdf_process($output_filename);
}


package Heterarch::Test::Output::Formatter::YAML::Summary;

# The Formatter:YAML::Summary package converts the test specifications
# to a YAML formatted summary.


our @ISA = ("Heterarch::Test::Output::Summarizer");


#
# Create the infrastructure for keeping module test results.
#

sub ex_mo_prepare
{
    my $self = shift;

    # get the execution context

    my $execution_context = $self->{execution_context};

    # create an output entry for the module

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    if (not $global_test_report->{selected}->{$module_name})
    {
	$global_test_report->{selected}->{$module_name} = [];
    }
    else
    {
	die "$0: *** Error: module_name $module_name is defined twice.";
    }
}


# add the current test description to the summary

sub ex_ct_run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # get the current module summary

    my $selected_module = $global_test_report->{selected}->{$module_name};

    # get the current test summary

    my $selected_command_definitions = $selected_module->[$#$selected_module]->{tests};

    # add the current test description to the summary

    push @$selected_command_definitions, $command_test->{description};

    # always succeeds

    my $test_result
	= {
	   after_match => "",
	   before_match => "",
	   error => "",
	   expected => "",
	   matched_pattern_position => "",
	   successfully_matching_string => "",
	  };

    return $test_result;
}


# create an output entry for the current command definition

sub ex_cd_start
{
    my $self = shift;

    # get the execution context

    my $execution_context = $self->{execution_context};

    # create an output entry for the module

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # create an output entry for the current command definition

    my $selected_module = $global_test_report->{selected}->{$module_name};

    my $command_definition = $execution_context->get_command_definition();

    push @$selected_module, { description => $command_definition->{description}, tests => [], };
}


# note that this implementation is the same as the one of ex_terminate() in
# Heterarch::Test::Output::Formatter::YAML::CommandTests

sub ex_terminate
{
    my $self = shift;

    my $fd_output = shift;

    my $test_module_library_contents = shift;

    # yaml out the test report

    my $report_yaml
	= {
	   description => $global_test_report->{description},
	  };

    # add output specific to the output selection

    if ($option_report_disabled)
    {
	$report_yaml->{disabled} = $global_test_report->{disabled};
    }

    $report_yaml->{selected} = $global_test_report->{selected};

    use YAML;

    my $report_text = "\n" . Dump($report_yaml);

    print $global_fd_output "$report_text\n";
}


package Heterarch::Test::Output::Formatter::YAML::CommandTests;

# The Formatter:YAML::CommandTests package converts the test
# specifications to a YAML formatted list of commands and their input
# in the write clauses, that would be executed if the tests are run.


our @ISA = ("Heterarch::Test::Output::Summarizer");


#
# Create the infrastructure for keeping module test results.
#

sub ex_mo_prepare
{
    my $self = shift;

}


# create an output entry for the current command definition
# add the current test description to the summary

sub ex_ct_run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # only if there is something to add

    if (exists $command_test->{write}
        and defined $command_test->{write})
    {
	# get the current module summary

	my $selected_module = $global_test_report->{selected}->{$module_name};

	# get the current test summary

	if (not exists $selected_module->[$#$selected_module]->{tests})
	{
	    $selected_module->[$#$selected_module]->{tests} = [];
	}

	my $selected_command_definitions = $selected_module->[$#$selected_module]->{tests};

	# add the current test write clause to the summary

	push @$selected_command_definitions, $command_test->{write};
    }

    # always succeeds

    my $test_result
	= {
	   after_match => "",
	   before_match => "",
	   error => "",
	   expected => "",
	   matched_pattern_position => "",
	   successfully_matching_string => "",
	  };

    return $test_result;
}


sub ex_cd_start
{
    my $self = shift;

    # get the execution context

    my $execution_context = $self->{execution_context};

    # create an output entry for the module

    #t we could add a counter here to keep the order of execution in the final yaml output

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    my $command_definition = $execution_context->get_command_definition();

    if (exists $command_definition->{command})
    {
	if (not $global_test_report->{selected}->{$module_name})
	{
	    $global_test_report->{selected}->{$module_name} = [];
	}

	# create an output entry for the current command definition

	my $selected_module = $global_test_report->{selected}->{$module_name};

	# retrieve the shell command and its arguments

	my ($command, $arguments) = $command_definition->parse_command_line();

	my $command_string = $command . ' ' . join ' ', @ { $arguments || [] };

	push @$selected_module, { command => $command_string, };
    }
}


# note that this implementation is the same as the one of ex_terminate() in
# Heterarch::Test::Output::Formatter::YAML::Summary

sub ex_terminate
{
    my $self = shift;

    my $fd_output = shift;

    my $test_module_library_contents = shift;

    # yaml out the test report

    my $report_yaml
	= {
	   description => $global_test_report->{description},
	  };

    # add output specific to the output selection

    if ($option_report_disabled)
    {
	$report_yaml->{disabled} = $global_test_report->{disabled};
    }

    $report_yaml->{selected} = $global_test_report->{selected};

    use YAML;

    my $report_text = "\n" . Dump($report_yaml);

    print $global_fd_output "$report_text\n";
}


package Heterarch::Test::Output::Definitions;

# The Heterarch::Test::Output::Definitions package should list all the
# supported constructs that can be used in the test specifications.
#
# This list has been developed in a separate emacs-org document.
#

our @ISA = ("Heterarch::Test::Output::Summarizer");


package Heterarch::Test::Output::List;

# this package should list the constructs used in the selected test
# specifications.

# inherit from the yaml summary to automate text context tracking through its start sub

our @ISA = ("Heterarch::Test::Output::Formatter::YAML::Summary");


sub ex_ct_run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

}


package Heterarch::Test::Output::StructureSummary;


sub ss_command_definitions
{
    my $self = shift;

    my $command_definitions = shift;

    $self->{cd_0} = scalar @$command_definitions eq 0 ? 1 : 0;
    $self->{cd_1} = scalar @$command_definitions eq 1 ? 1 : 0;
    $self->{cd_1_comment} = $self->{cd_1} && exists $command_definitions->[0]->{comment};
}


sub ss_command_tests
{
    my $self = shift;

    my $command_tests = shift;

    $self->{ct_0} = defined $command_tests && scalar @$command_tests eq 0 ? 1 : 0;
    $self->{ct_1} = defined $command_tests && scalar @$command_tests eq 1 ? 1 : 0;
}


sub ss_figure_references
{
    my $self = shift;

    my $figure_references = shift;

    # $self->{fr_0} = scalar @$figure_references eq 0 ? 1 : 0;
    # $self->{fr_1} = scalar @$figure_references eq 1 ? 1 : 0;
}


sub new
{
    my $package = shift;

    my $self
	= {
	   cd_0 => undef,
	   cd_1 => undef,
	   cd_1_comment => undef,
	   ct_0 => undef,
	   ct_1 => undef,
	   # fr_0 => undef,
	   # fr_1 => undef,
	  };

    bless $self, $package;

    return $self
}


package Heterarch::Test::Reporting;


sub report_error_add
{
    my $fd_output = shift;

    my $arguments = shift;

    my $description = $arguments->{description};
    my $error = $arguments->{error};
    my $expected = $arguments->{expected};
    my $message = $arguments->{message};
    my $module_name = $arguments->{module_name};
    my $seen = $arguments->{seen};
    my $subdescription = $arguments->{subdescription};

    my $package_name = $global_test_report->{description}->{package}->{name};

    if (defined $option_debugging
	and $option_debugging eq 'errors')
    {
	use Carp;

	warn "$0: DEBUG errors";

	print Carp::cluck(@_);
    }

    $global_error_count++;

    print $fd_output "*** Error $global_error_count: $error ($description, package $package_name, $module_name, error_count $global_error_count)\n";

    # fill in the error report

    $global_test_report->{global}->{error_count} = $global_error_count;

    if ($subdescription)
    {
	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{$subdescription}->{description} = $description;
    }
    else
    {
	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{description} = $description;
    }

    $global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{error} = $error;

    if (defined $message)
    {
	#! subdescription can be undefined here, in which case
	#! $message is undefined too.  Both can be defined when
	#! running in verbose mode seems, allows to track regex
	#! problems ... I think.

	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{$subdescription}->{report} = $message;
    }

    if (defined $expected
	and defined $seen)
    {
	my $processed_expected = [ split "\n", $expected, ];

	$processed_expected = join "\n*** Error $global_error_count: expected: ", "", @$processed_expected, "\n";

	print $fd_output $processed_expected;

	my $processed_seen = [ split "\n", $seen, ];

	$processed_seen = join "\n*** Error $global_error_count: seen: ", "", @$processed_seen, "\n";

	print $fd_output $processed_seen;

	use IO::File;

	my $expected_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.expected";

	my $expected_file = IO::File->new(">$expected_filename");

	if ($expected_file)
	{
	    print $expected_file $expected;

	    $expected_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $expected_filename for writing\n";
	}

	my $seen_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.seen";

	my $seen_file = IO::File->new(">$seen_filename");

	if ($seen_filename)
	{
	    print $seen_file $seen;

	    $seen_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $seen_filename for writing\n";
	}

	my $diff = `diff "$expected_filename" "$seen_filename"`;

	my $diff_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.diff";

	my $diff_file = IO::File->new(">$diff_filename");

	if ($diff_file)
	{
	    print $diff_file $diff;

	    $diff_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $diff_filename for writing\n";
	}

	my $processed_diff = [ split "\n", $diff, ];

	$processed_diff = join "\n*** Error $global_error_count: diff: ", "", @$processed_diff, "\n";

	print $fd_output $processed_diff;
    }

}


my $rulers_not_used
    = {
       end => { bottom => 2, top => 1, },
       info => { bottom => 1, top => 1, },
       start => { bottom => 1, top => 2, },
      };

sub report_message
{
    my $fd_output = shift;

    my $message = shift;

    print $fd_output "$message\n";
}


sub report_message_end
{
    my $fd_output = shift;

    my $message = shift;

    return _report_message_with_rulers($fd_output, 1, 2, $message);
}


sub report_message_info
{
    my $fd_output = shift;

    my $message = shift;

    return _report_message_with_rulers($fd_output, 1, 1, $message);
}


sub report_message_start
{
    my $fd_output = shift;

    my $message = shift;

    return _report_message_with_rulers($fd_output, 2, 1, $message);
}


sub _report_message_with_rulers
{
    my $fd_output = shift;

    my $top_ruler = shift;

    my $bottom_ruler = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print $fd_output "\n";
    print $fd_output "$line\n" for 0 .. $top_ruler;
    print $fd_output "\n";
    print $fd_output "$message\n\n";
    print $fd_output "$line\n" for 0 .. $bottom_ruler;
    print $fd_output "\n";
}


package main;


main();


