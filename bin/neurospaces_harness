#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
#
# $Id: run 1.80 Wed, 26 Dec 2007 21:42:57 -0600 hugo $
#

use strict;


my $loaded_mail_sender = eval "require Mail::Sender";

use Data::Transformator;

use Expect;

use Getopt::Long;

use Neurospaces::Tester;;

use YAML;


my $option_check_test_names;
my $option_dump_json;
my $option_dump_perl;
my $option_dump_yaml;
my $option_email = defined $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} ? $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} : 0 ;
my $option_flattenout;
my $option_help;
my $option_numerical_compare;
my $option_output_html;
my $option_output;
my $option_random_order;
my $option_regex_selector = ".*";
my $option_report_disabled;
my $option_show;
my $option_tags = [];
my $option_timeout_multiplier = 1;
my $option_timings;
my $option_trace;
my $option_verbose;


our $global_config;

my $global_error_count = 0;
my $global_fd_output;
my $global_previous_command_side_effects;
my $global_test_report;


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $global_test_report->{global}->{status} = 'Died';

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $global_test_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub initialize_environment
{
    my $fd_initialization;

    open($fd_initialization, ">&STDOUT");

    my $environment_settings = $global_config->{environment_settings};

    foreach my $environment_setting_name (keys %$environment_settings)
    {
	my $environment_setting = $environment_settings->{$environment_setting_name};

	# if simply setting values in the environment

	if (!ref $environment_setting)
	{
	    # set the value in the environment

	    $ENV{$environment_setting_name} = $environment_setting;
	}

	# if additional initialization required

	elsif (ref $environment_setting eq 'HASH')
	{
	    # get environment_setting value

	    my $value = $environment_setting->{value};

	    # set the value in the environment

	    $ENV{$environment_setting_name} = $value;

	    # give feedback

	    my $description = $environment_setting->{description};

	    $description =~ s/%value/$value/g;

	    if ($option_verbose)
	    {
		print $fd_initialization $description;
	    }

	    # loop over shell commands for initialization

	    my $shell_commands = $environment_setting->{initialization}->{shell};

	    foreach my $shell_command (@$shell_commands)
	    {
		# replace value

		$shell_command =~ s/%value/$value/g;

		# execute command

		if ($option_verbose)
		{
		    print $fd_initialization "$0: executing ($shell_command)\n";
		}

		system $shell_command;
	    }
	}
	else
	{
	    die "$0: illegal environment_settings, was processing $environment_setting";
	}
    }
}


sub initialize_globals
{
    $global_test_report
	= {
	   description => {
			   command => $0,
			   name => "Test report",
			   package => $global_config->{package},
			  },
	   global => {
		      config => $global_config,
		      error_count => $global_error_count,
		      status => 'initializing',
		      test_count => 0,
		      time_start => `date`,
		     },
	   target => {
		      OS => $^O,
		      system => {
				 libc => (join '', `(ls -l /lib/libc-* && ls -l /usr/lib/libc-*) 2>/dev/null`),
				 uname => (join '', `uname -a`),
				 cpu => (join '', `cat /proc/cpuinfo`),
				},
		      packages => {
				   '/etc/lsb-release' => (join '', `cat /etc/lsb-release`),
				   autoconf => (join '', `autoconf --version`),
				   automake => (join '', `automake --version`),
				   bison => (join '', `bison --version`),
				   flex => (join '', `flex --version`),
				   gcc => (join '', `gcc 2>&1 --version && gcc 2>&1 -v`),
				   perl => (join '', `perl 2>&1 -v && perl 2>&1 -V`),
				   python => (join '', `python 2>&1 --version`),
				   python_installation => (join '', `./contrib/pythontest 2>&1`),
				   swig => (join '', `swig 2>&1 -version`),
				  },
		     },
	  };
}


sub initialize_running_mode
{
    # find the package core directory

    $global_config = do './tests.config';

    if (!defined $global_config)
    {
	die "No test configuration found";
    }

    # add to tests directory to include paths

    if (!exists $global_config->{tests_directory})
    {
	$global_config->{tests_directory} = "./tests/specifications";
    }

    unshift @INC, $global_config->{tests_directory};
}


sub main
{
    parse_options();

    initialize_running_mode();

    initialize_environment();

    initialize_globals();

    open($global_fd_output, ">&STDOUT");

    # find all the test module files

    my $test_modules = Heterarch::Test::Library::construct();

    # read the test module files

    $test_modules = Heterarch::Test::Library::expand($global_fd_output, $test_modules);

    # total test count so far is zero

    my $test_count = 0;

    # compute the model library checksum

    my $library_sha_before;

    if (defined ($global_config->{model_library}))
    {
	$library_sha_before = ModelLibrary::sha();
    }

    # the previous command had no side effects on the loaded model (since there is no model yet)

    $global_previous_command_side_effects = 0;

    # set status: running

    $global_test_report->{global}->{status} = 'Running';

    # randomize test module order if requested

    if (defined $option_random_order)
    {
	if ($option_verbose)
	{
	    print $global_fd_output "Randomizing test specifications, random seed is $option_random_order\n";
	}

	# by default the randomizer will choose a random_seed

	my $random_seed;

	if ($option_random_order =~ /^[0-9]*$/
	    and $option_random_order ne 1)
	{
	    $random_seed = $option_random_order
	}

	# randomize the test module library

	( $test_modules, $random_seed ) = Heterarch::Test::Library::randomize_order($test_modules, $random_seed);

	$global_test_report->{random_seed} = $random_seed;
    }
    else
    {
	$global_test_report->{random_seed} = 'not randomized';
    }

    $global_test_report->{global}->{test_count} = 0;

    # create an execution context for running the tests

    my $execution_context = Heterarch::Test::ExecutionContext->new($global_fd_output);

    # create a test executor for running the tests following the requested type of output

    my $executor = $option_output->new($execution_context);

    # loop over all module definitions

    foreach my $module_definition (@$test_modules)
    {
	bless $module_definition, "Heterarch::Test::Module";

	my $fd_module_output = $global_fd_output;

	my $module_name = $module_definition->check_name($fd_module_output);

	my $module_description = $module_definition->check_description($fd_module_output);

	if (not $module_definition->is_selected_by_tag($fd_module_output))
	{
	    next;
	}

	# proceed: start the execution context

	my $started = $execution_context->start($module_definition);

	if (not $started)
	{
	    next;
	}

	# prepare the module test environment

	my $module_preparation_result = $execution_context->preparation($module_definition);

	# loop over commands for this module

	my $command_definitions = $module_definition->{command_definitions};

	foreach my $command_definition (@$command_definitions)
	{
	    bless $command_definition, "Heterarch::Test::CommandDefinition";

	    # give some diagnostics

	    my $started = $execution_context->start($module_definition, $command_definition);

	    if (not $started)
	    {
		next;
	    }

	    # prepare the command test environment

	    my $preparation_result = $execution_context->preparation($module_definition, $command_definition);

	    $executor->start();

	    # loop over all tests for this command

	    my $command_tests = $command_definition->{command_tests};

	    foreach my $command_test (@$command_tests)
	    {
		bless $command_test, "Heterarch::Test::CommandTest";

		# lookup the class for this command

		$command_test->rebless();

		# emit comment if any

		my $started = $execution_context->start($module_definition, $command_definition, $command_test);

		if (not $started)
		{
		    next;
		}

		# run the text executor

		my $execution_result = $executor->run($command_test);

		# process errors

		my $error = $execution_result->{error};

		if ($error)
		{
		    my $description = $command_test->{description};

		    my $command_definition_description = $command_definition->{description};

		    my $message;

		    my $before_match = $execution_result->{before_match};

		    if ($option_verbose)
		    {
			$message = $before_match;
		    }

 		    Heterarch::Test::Reporting::report_error_add
			(
			 $fd_module_output,
			 {
			  description => $description,
			  error => $error,
			  expected => $execution_result->{expected},
			  message => $message,
			  module_name => $module_name,
			  seen => $before_match,
			  subdescription => $command_definition_description,
			 },
			);

		}

		# end the execution of this test

		$execution_context->end($module_definition, $command_definition, $command_test);

		# register if this command had side effects

		$global_previous_command_side_effects ||= $command_test->{side_effects} || 0;

		# increment total test count

		$global_test_report->{global}->{test_count}++;
	    }

	    # repair the command test environment

	    my $reparation_error = $execution_context->reparation($command_definition, $preparation_result);

	    $execution_context->end($module_definition, $command_definition);

	    # register if this command had side effects

	    #! e.g. using a preparer/reparer combination

	    $global_previous_command_side_effects ||= $command_definition->{side_effects} || 0;
	}

	# repair the test environment

	my $reparation_error = $execution_context->reparation(undef, $module_preparation_result);

	# if library checksum mismatch

	if (defined ($global_config->{model_library}))
	{
	    my $library_sha_after = ModelLibrary::sha();

	    if ($library_sha_after ne $library_sha_before)
	    {
		my $error = 'model library checksum mismatch (model library has changed)';

		my $description = $module_definition->{description};

		Heterarch::Test::Reporting::report_error_add
		    (
		     $fd_module_output,
		     {
		      description => $description,
		      error => $error,
		      module_name => $module_name,
		     },
		    );
	    }
	}

	# register if this command had side effects

	#! don't think this make sense, but anyway ...

	$global_previous_command_side_effects ||= $module_definition->{side_effects} || 0;

	$execution_context->end($module_definition);
    }

    # end the execution_context

    $execution_context->terminate();

    # close pending commands

    Heterarch::Test::CommandDefinition::close_pending();

    # close the test report

    $global_test_report->{global}->{status} = 'Finished';

    # final report

    report_exit(0);
}


sub parse_options
{
    $option_numerical_compare = $global_config->{numerical_compare} || 0;

    my $result
	= GetOptions
	    (
	     "check-test-names!" => \$option_check_test_names,
	     "dump-json!" => \$option_dump_json,
	     "dump-perl!" => \$option_dump_perl,
	     "dump-yaml!" => \$option_dump_yaml,
	     "email" => \$option_email,
	     "flattenout" => \$option_flattenout,
	     "help!" => \$option_help,
	     "numerical-compare!" => \$option_numerical_compare,
	     "output=s" => \$option_output,
	     "output-html" => \$option_output_html,
	     "randomize-order=s" => \$option_random_order,
	     "regex-selector=s" => \$option_regex_selector,
	     "report-disabled!" => \$option_report_disabled,
	     "show!" => \$option_show,
	     "tags=s" => $option_tags,
	     "timeout-multiplier=s" => \$option_timeout_multiplier,
	     "timings!" => \$option_timings,
	     "trace!" => \$option_trace,
	     "v|verbose+" => \$option_verbose,
	    );

    if (!$result)
    {
	die "$0: Error in option processing";
    }

    if (not defined $option_output)
    {
	if ($option_output_html)
	{
	    $option_output = "Heterarch::Test::Output::Formatter::HTMLTable";
	}
	elsif ($option_show)
	{
	    $option_output = "Heterarch::Test::Output::Formatter::YAML::Summary";
	}
	else
	{
	    $option_output = "Heterarch::Test::Executor";
	}
    }

    $global_test_report->{options}
	= {
	   dump_json => $option_dump_json,
	   dump_perl => $option_dump_perl,
	   dump_yaml => $option_dump_yaml,
	   email => $option_email,
	   flattenout => $option_flattenout,
	   help => $option_help,
	   numerical_compare => $option_numerical_compare,
	   output_html => $option_output_html,
	   random_order => $option_random_order,
	   regex_selector => $option_regex_selector,
	   report_disabled => $option_report_disabled,
	   show => $option_show,
	   tags => $option_tags,
	   timeout_multiplier => $option_timeout_multiplier,
	   timings => $option_timings,
	   trace => $option_trace,
	   verbose => $option_verbose,
	  };

    if ($option_help)
    {
	print
	    "
$0: test definition executor

options:
    --check-test-names   check the pathnames of the specification files against the names of the tests.
    --dump-json          dump test specifications to json files in /tmp/.
    --dump-perl          dump test specifications to perl files in /tmp/.
    --dump-yaml          dump test specifications to yaml files in /tmp/.
    --email              allow to send emails, the default is taken from \$ENV{NEUROSPACES_HARNESS_OPTION_EMAIL}.
    --flattenout         flattenout the test definitions before testing,
                         this experimental feature might increase test performance,
                         by recycling test definitions.
    --help               print usage information.
    --numerical-compare  attempt to compare numbers numerically when string differences are found (default enabled).
    --output             the class that should generate the output (default is '$option_output').
    --output-html        generate HTML output.
    --randomize-order    randomize the order of the tests before executing them (require List::Util to be installed).
    --regex-selector     defines a regex to run specific tests.
    --report-disabled    include information of disabled tests in the test report.
    --show               show tests that would be run using the current configuration.
    --tags               only test test modules that have been tagged with these tags (default: all tags).
    --timeout-multiplier multiply all timeout values with this constant.
    --timings            add timing information about the tests to the report.
    --trace              enable tracing using the strace unix shell command.
    --verbose            set verbosity level.
";

	exit 1;
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $global_test_report->{global}->{time_end} = `date`;

    if (defined $description
        && $exit_code eq 3)
    {
	print STDERR "*** die: $description\n";
    }

    # yaml out the test report

    my $report_text
	= "\n"
	    . Dump(
		   {
		    description => $global_test_report->{description},
		    ($option_report_disabled ? (disabled => $global_test_report->{disabled}) : ()),
		    ($option_show ? () : (errors => $global_test_report->{errors})),
		    ($option_show ? () : (global => $global_test_report->{global})),
		    ($option_show ? (selected => $global_test_report->{selected}) : ()),
		   },
		  );

    print $global_fd_output "$report_text\n";

    # and write the full report to a file

    my $report_filename = ">/tmp/report_$global_config->{package}->{name}.yml";

    eval
    {
	YAML::DumpFile($report_filename, $global_test_report);
    };

    if ($@)
    {
	print STDERR "*** Error: Failed to write output report to $report_filename\n";
    }
    else
    {
	print $global_fd_output "*** Info: See '$report_filename' for the detailed test report\n";
    }

    # if email enabled by the options

    if ($option_email)
    {
	# check for a default route

	#! from perl/basic.t

	my $no_default_route = (`/sbin/route` =~ /default/ ? '' : 'no default route to the internet found');

	if (!$no_default_route)
	{
	    # ask if sending an email is ok

	    my $default_answer_prompt = $global_error_count ? "Y/n" : "y/N";

	    print $global_fd_output "\n---\n  These tests generated $global_error_count error(s)";
	    print $global_fd_output ( $global_error_count ? "  Because errors were found, you should really consider sending an email to inform the developer of this software package\n" : "" );
	    print $global_fd_output "\n  Ok to send an email to hugo.cornelis\@gmail.com for this test report,\n  this email will not reveal your identity to the recipient ?  [$default_answer_prompt]";

	    my $answer = readline(*STDIN);

	    # send an email if ok

	    if ($answer =~ /^y/)
	    {
		#t perhaps should consider Mail::Builder, don't know

		if ($loaded_mail_sender)
		{
		    my $sender
			= Mail::Sender->new
			    (
			     {
# 			      smtp => 'googlemail.l.google.com',
			      smtp => 'mta1.uthscsa.edu',
			      from => 'hugo.cornelis@gmail.com',
			     },
			    );

		    print $global_fd_output "Sending ... should not take more than 30 seconds
";

		    my $message
			= (
			   "neurospaces_harness test report\n"
			   . "Generated on " . `date` . "\n"
			   . "\n========\n"
			   . Dump($global_test_report)
			   . "\n========\n"
			  );

		    $sender->MailMsg
			(
			 {
			  to => 'cornelis@uthscsa.edu',
			  subject => '[neurospaces_harness] test report',
			  msg => $message,
			 },
			);

		    # 	    $sender->Attach
		    # 		(
		    # 		 {
		    # 		  description => 'global_test_report',
		    # 		 },
		    # 		);

		    $sender->Close();

		    if ($sender->{error})
		    {
			print STDERR
			    "*** Error: $sender->{error}
Email was not sent.
";
		    }
		    else
		    {
			print $global_fd_output
			    "Email was sent.
";
		    }
		}
		else
		{
		    print STDERR
			"*** Error: Cannot load the perl module Mail::Sender, contact your sysadmin to install this perl module.
(use the shell command \"sudo perl -MCPAN -e 'install Mail::Sender'\")
Email was not sent.
";
		}
	    }
	    else
	    {
		print $global_fd_output
		    "Email was not sent.
";
	    }
	}
	else
	{
	    print STDERR "*** Warning: No default route to the internet found.
Email was not sent.
";
	}
    }
    else
    {
	print $global_fd_output "No email sent.
";
    }

    # if there were errors

    if ($global_error_count)
    {
	# exit with failure

	$exit_code ||= 1;

	print $global_fd_output "$0: $global_test_report->{global}->{test_count} test(s), $global_error_count error(s)\n";

	print $global_fd_output "$0: exit_code $exit_code\n\n";

	exit $exit_code;
    }

    # else

    else
    {
	# exit, possibly success

	print $global_fd_output "$0: $global_error_count error(s)\n\n";

	exit $exit_code;
    }
}


package ModelLibrary;


sub sha
{
    # find all models

    use File::Find::Rule;

    my $files = [ File::Find::Rule->file()->in( $ENV{NEUROSPACES_NMC_MODELS} ), ];

    my $shas
	= [
	   map
	   {
	       `sha1sum $_`;
	   }
	   @$files,
	  ];

    use Digest::SHA qw(sha1_hex);

    my $sha = sha1_hex(join ', ', @$shas);

    return $sha;
}


package Heterarch::Test::CommandDefinition;


our @ISA = ("Heterarch::Test::Element");


use Data::Comparator qw(data_comparator);


my $global_exp;

my $global_running_command_definition;


sub close_pending
{
    # if there is a command running

    if ($global_exp)
    {
	# terminate the command

	#t could be that the hard_close() call is needed because
	#t neurospaces uses readline, not sure needs investigation,
	#t perhaps.

	$global_exp->hard_close();
    }
}


sub spawn_new
{
    my $command_definition = shift;

    my $fd_output = shift;

    # a command can be an absolute pathname,
    # can come from the _build directory
    # or from the sources for a script

# 		-f $command and print "Found command $command\n";
# 		-f $built_exe_directory . $command and print "Found built $built_exe_directory$command\n";
# 		-f $core_directory . $command and print "Found core $core_directory$command\n";

    my $command = $command_definition->{command};

    my $test_command = $command;
    # = (-f $command
    #    ? $command
    #    : (defined $built_exe_directory
    #       ? (-f $built_exe_directory . $command
    #        ? $built_exe_directory . $command
    #        : $core_directory . $command)
    #       : $command));

    # find differences between how to run this command and
    # the one already running

    my $new_command_definition
	= {
	    arguments => $command_definition->{arguments},
	    command => $test_command,
	  };

    my $differences = data_comparator($new_command_definition, $global_running_command_definition);

    # remember to spawn a new command

    my $spawn_new;

    $spawn_new = not $command_definition->{recycle};

    # (
	#  # if we do not have a previous command

	#  (not $global_exp)

	#  # or if there were differences with the previous command

	#  || (not $differences->is_empty())

	#  # or if the previous command had side effects

	#  || $global_previous_command_side_effects

	#  # or if we had to prepare this command

	#  || $command_definition->{preparation}
	# )
	# && (not $command_definition->{recycle});

    # prefix the command with the core directory

    $command = $new_command_definition->{command};

    my $arguments = $command_definition->{arguments};

    # if the command can be executed

    my $test_startup;

# 		    if (-x $command)
    if (defined $command)
    {
	if ($spawn_new)
	{
	    if ($global_exp)
	    {
		# terminate the previous command

		#t could be that the hard_close() call is needed because
		#t neurospaces uses readline, not sure needs investigation,
		#t perhaps.

		$global_exp->hard_close();
	    }

	    # create a new Expect object by spawning a new process with the new command

	    $global_exp = Expect->new();

	    #! see the expect manual for this one

	    $global_exp->raw_pty(1);

	    # 		    $exp->slave->stty(qw(raw -echo));

	    $global_exp->spawn
		(
		 (
		  $option_trace
		  ? ("strace", "-f")
		  : ()
		 ),
		 $command,
		 @$arguments
		)
		or die "$0: cannot spawn $command: $!\n";

	    # set the running_command_definition

	    $global_running_command_definition = $new_command_definition;

	    print $fd_output "*** Executing $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";

	    # remember to do startup testing

	    $test_startup = 1;

	    # there were no side effects yet

	    $global_previous_command_side_effects = 0;
	}
	else
	{
	    print $fd_output "*** Recycling $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";

	    $test_startup = 0;
	}
    }
    # else
    # {
    # 	my $error = "$command is not executable";

    # 	Heterarch::Test::Reporting::report_error_add
    # 	    (
    # 	     {
    # 	      description => $description,
    # 	      error => $error,
    # 	      module_name => $module_name,
    # 	     },
    # 	    );

    # 	next;
    # }

    return $global_exp, $test_startup;
}


package Heterarch::Test::CommandTest;


our @ISA = ("Heterarch::Test::Element");


sub after_run
{
    my $self = shift;

    my $execution_context = shift;

    my $test_result = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    my $time_start = $self->{time_start};

    my $time_elapsed = tv_interval($time_start);

    # fill in the elapsed time in the report

    if ($option_timings)
    {
	my $module_definition = $self->{module_definition};

	my $module_name = $module_definition->{name};

	my $description = $self->{description};

	$global_test_report->{timings}->{$module_name}->{$description} = $time_elapsed;
    }

    # attempt to correct if the result is almost correct

    #! perl code does not produce a full test result object, so we cannot try to correct an almost correct result

    if (not (ref $command eq 'CODE'))
    {
	# if things don't match

	if ($test_result->{error})
	{
	    my $module_definition = $self->{module_definition};

	    # if allowed to compare numerically

	    if ((!$self->{string_only}
		 && $option_numerical_compare)

		# or forced to compare numerically

		|| $self->{numerical_compare}
		|| $command_definition->{numerical_compare}
		|| $module_definition->{numerical_compare})
	    {
		# compare numerically

		push @{$global_test_report->{numerical_compare}}, $self->{description};

		#! this call uses the $read variable, making it harder to bring this call
		#! outside the condition that tests if this variable is defined
		#! this variable contains the expected output

		$test_result->{error}
		    = Neurospaces::Tester::Comparators::numerical
		        (
			 {
			  description => $self->{description},
			 },
			 $test_result->{before_match},
			 $test_result->{expected},
			 $test_result->{error});
	    }
	}
    }

    # return result

    return $test_result;
}


sub before_run
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # record time

    use Time::HiRes qw(gettimeofday tv_interval);

    my $time_start = [ gettimeofday(), ];

    $self->{time_start} = $time_start;
}


sub rebless
{
    my $command_test = shift;

    my $target_package = "Heterarch::Test::CommandTest";

    if (ref $command_test->{write} eq 'ARRAY')
    {
	# command_object

	$target_package = "Heterarch::Test::CommandTest::CommandObject";

	my $writes = $command_test->{write};

	foreach my $write (@$writes)
	{
	    my $method = $write->{method};

	    my $arguments = $write->{arguments};
	}

	# compare the read data with what is expected

	if (exists $command_test->{read})
	{
	    my $read = $command_test->{read};
	}
    }

    # if the command_definition has executable perl code

    # elsif (ref $command eq 'CODE')
    # {
	# $target_package = "Heterarch::Test::CommandTest::PerlCode";

    # }

    # else the command definition runs a shell command

    else
    {
	# set read, wait and write strings

	$target_package = "Heterarch::Test::CommandTest::Interactive";

	my $read = $command_test->{read};

	my $wait = $command_test->{wait};

	my $write = $command_test->{write};

	# set timeout, defaults to two seconds, but for newly created processes add two additional seconds.

	my $timeout
	    = (defined $command_test->{timeout}
	       ? $command_test->{timeout} * $option_timeout_multiplier
	       : (0
		  ? 4 * $option_timeout_multiplier
		  : 2 * $option_timeout_multiplier));

	# write

	if (ref $write eq 'HASH')
	{
	}
	elsif (defined $write)
	{
	    # send write to the command under test via the expect object
	}

	# wait

	if ($wait)
	{
	    # wait for $wait seconds
	}

	# check the shell command that will be executed with a timeout

	my $shell = $command_test->{shell};

	if (ref $shell eq 'HASH')
	{
	    #! not sure what this can be
	}
	elsif (defined $shell)
	{
	    # run the command for a maximum of $timeout seconds

	    # fall through
	}

	# if there is an external application to test the final output

	#! the previous shell command was a post-processor, this one is a tester

	my $tester = $command_test->{tester};

	if ($tester)
	{
	    $target_package = "Heterarch::Test::CommandTest::Interactive::ShellTester";

	    # set the external tester that compares the generated output with what is expected

	    #! the external tester runs an executable shell command

	    my $shell = $tester->{shell};

	    # there must be a shell command we should run

	    if ($shell)
	    {
		my $produced = `$shell`;

		my $test_result
		    = {
		       expected => defined $tester->{expected} ? $tester->{expected} : '',
		      };

		if (($produced eq ''
		     and $test_result->{expected} ne '')
		    or ($produced ne ''
			and $test_result->{expected} eq ''))
		{
		    $test_result->{error} = "external tester produces output that is different from what is expected, one is empty, the other is not";

		    $test_result->{before_match} = $produced;
		}
		elsif ($produced =~ /$test_result->{expected}/)
		{
		}
		else
		{
		    $test_result->{error} = "the external tester produces output that is different from the expected output";

		    $test_result->{before_match} = $produced;
		}
	    }
	    else
	    {
		die "$0: *** Error: external testers must have a shell command";
	    }
	}

	# read

	elsif (defined $read)
	{
	    # if literal text expected

	    if (!ref $read)
	    {
		if (exists $command_test->{white_space})
		{
		    if ($command_test->{white_space} eq 'convert seen 0a to 0d 0a newlines')
		    {
			$read =~ s(\x0a)(\x0d\x0a)g;
		    }
		}

		$target_package = "Heterarch::Test::CommandTest::Interactive::Literal";

		# expect $read for output
	    }

	    # if array, means regex match

	    elsif (ref $read eq 'ARRAY')
	    {
		# expect $read to match as a regex with the output

		$target_package = "Heterarch::Test::CommandTest::Interactive::Regex";

	    }

	    # else, hash: one of several alternatives expected

	    else
	    {
		# compose the alternatives regex

		if ($read->{alternatives})
		{
		    # expect that the output literally matches with one of the given alternatives

		    $target_package = "Heterarch::Test::CommandTest::Interactive::Alternatives";

		    my $alternatives = $read->{alternatives};
		}

		# if an application output file is expected

		elsif ($read->{application_output_file})
		{
		    $target_package = "Heterarch::Test::CommandTest::Interactive::File";

		    # read it

		    my $application_output_file = $read->{application_output_file};

		    # and literally compare it with an expected output file or with the {expected_output}

		    my $expected_output_file = $read->{expected_output_file};

		    local $/;

		    my $application_output = `cat "$application_output_file"`;

		    if ($expected_output_file)
		    {
		    }
		    elsif (defined $read->{expected_output})
		    {
		    }
		}

		# if there is a shell command given

		elsif ($read->{shell})
		{
		    $target_package = "Heterarch::Test::CommandTest::Interactive::Shell";

		    # run it and capture its output

		    my $shell = $read->{shell};

		    # and compare its output with the output of the application
		}
		else
		{
		    my $description = $command_test->{description};

		    die "test not understood by $0, aborting (illegal read clause for $description)";
		}
	    }
	}
    }

    # almost correct processing

    #! perl code does not produce a full test result object, so we cannot try to correct an almost correct result

    # {
    # 	# if things don't match

    # 	{
	    # # if allowed to compare numerically

	    # if ((!$command_test->{string_only}
	    # 	 && $option_numerical_compare)

	    # 	# or forced to compare numerically

	    # 	|| $command_test->{numerical_compare}
	    # 	|| $command_definition->{numerical_compare}
	    # 	|| $module_definition->{numerical_compare})
	    # {
	    # }
    # 	}
    # }

    # rebless

    bless $command_test, $target_package;

    # return result

    return $command_test;
}


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # if the command_definition has executable perl code

    if (ref $command eq 'CODE')
    {
	# execute the perl code

	use Cwd;

	my $directory = getcwd();

	my $error
	    = &$command
	    (
	     $self,
	     {
	      c_code => {
			 directory => $directory,
			},
	     },
	    );

	$test_result
	    = {
	       error => $error,
	      };
    }

    # return result

    return $test_result;
}


package Heterarch::Test::CommandTest::CommandObject;


our @ISA = ("Heterarch::Test::CommandTest");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # record time

    $self->before_run($execution_context, $fd_output);

    # if the command_definition instantiated an object

    my $command_object = $executor->{command_object};

    if ($command_object
	and (ref $self->{write} eq 'ARRAY'))
    {
	# write data to the object using the given methods
	# and arguments and obtain a result from the
	# object

	my $result;

	my $last_method;

	my $writes = $self->{write};

	foreach my $write (@$writes)
	{
	    my $method = $write->{method};

	    $last_method = $method;

	    my $arguments = $write->{arguments};

	    $result = $command_object->$method(@$arguments);
	}

	# compare the read data with what is expected

	if (exists $self->{read})
	{
	    my $read = $self->{read};

	    $test_result
		= {
		   error => ($result eq $read
			     ? ""
			     : "$last_method returned $result, expected $read"),
		   before_match => $result,
		   expected => $read,
		  };
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive;


our @ISA = ("Heterarch::Test::CommandTest");


sub get_timeout
{
    my $self = shift;

    my $test_startup = $self->{test_startup};

    my $result
	= (defined $self->{timeout}
	   ? $self->{timeout} * $option_timeout_multiplier
	   : ($test_startup
	      ? 4 * $option_timeout_multiplier
	      : 2 * $option_timeout_multiplier));

    return $result;
}


sub prepare_run
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    # check the shell command that will be executed with a timeout

    my $shell = $self->{shell};

    if (ref $shell eq 'HASH')
    {
	#! not sure what this can be
    }
    elsif (defined $shell)
    {
	# run the command for a maximum of $timeout seconds

	# allow it to post-process results generated by the command that is being tested

	my $timeout = $self->get_timeout();

	print $fd_output "*** Shell: timeout $timeout $shell\n";

	system "timeout $timeout $shell";

	#t check the output or status of the shell command?

	# fall through
    }

    #t return something sensible

    return $?;
}


sub process_wait
{
    my $self = shift;

    my $execution_context = shift;

    my $fd_output = shift;

    my $wait = $self->{wait};

    # wait

    if ($wait)
    {
	print $fd_output "*** Wait: $wait\n";

	select(undef, undef, undef, $wait);
    }

}


sub process_write
{
    my $self = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $write = $self->{write};

    # write

    if (ref $write eq 'HASH')
    {
    }
    elsif (defined $write)
    {
	print $fd_output "*** Write: $write\n";

	$executor->{expect_object}->send("$write\n");
    }
}


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::ShellTester;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # if there is an external application to test the final output

    #! the previous shell command was a post-processor, this one is a tester

    my $tester = $self->{tester};

    if ($tester)
    {
	# set the external tester that compares the generated output with what is expected

	#! the external tester runs an executable shell command

	my $shell = $tester->{shell};

	# there must be a shell command we should run

	if ($shell)
	{
	    my $produced = `$shell`;

	    $test_result
		= {
		   expected => defined $tester->{expected} ? $tester->{expected} : '',
		  };

	    #			    if ($expected)
	    {
		#				$expected = quotemeta $tester->{expected};

		if (($produced eq ''
		     and $test_result->{expected} ne '')
		    or ($produced ne ''
			and $test_result->{expected} eq ''))
		{
		    $test_result->{error} = "external tester produces output that is different from what is expected, one is empty, the other is not";

		    $test_result->{before_match} = $produced;
		}
		elsif ($produced =~ /$test_result->{expected}/)
		{
		}
		else
		{
		    $test_result->{error} = "the external tester produces output that is different from the expected output";

		    $test_result->{before_match} = $produced;
		}
	    }
	    # 			    else
	    # 			    {
	    # 				die "$0: *** Error: external testers must have expected output";
	    # 			    }
	}
	else
	{
	    die "$0: *** Error: external testers must have a shell command";
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Literal;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # read

    if (defined $read)
    {
	# if literal text expected

	if (!ref $read)
	{
	    if (exists $self->{white_space})
	    {
		if ($self->{white_space} eq 'convert seen 0a to 0d 0a newlines')
		{
		    print $fd_output "*** Converting seen 0a to 0d 0a newlines\n";

		    $read =~ s(\x0a)(\x0d\x0a)g;
		}
	    }

	    my $timeout = $self->get_timeout();

	    my ($matched_pattern_position,
		$error,
		$successfully_matching_string,
		$before_match,
		$after_match)
		= $executor->{expect_object}->expect($timeout, $read, );

	    $test_result
		= {
		   matched_pattern_position => $matched_pattern_position,
		   error => $error,
		   successfully_matching_string => $successfully_matching_string,
		   before_match => $before_match,
		   after_match => $after_match,
		   expected => $read,
		  };
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Regex;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # read

    if (defined $read)
    {
	# if array, means regex match

	if (ref $read eq 'ARRAY')
	{
	    my $timeout = $self->get_timeout();

	    my ($matched_pattern_position,
		$error,
		$successfully_matching_string,
		$before_match,
		$after_match)
		= $executor->{expect_object}->expect($timeout, @$read, );

	    $test_result
		= {
		   matched_pattern_position => $matched_pattern_position,
		   error => $error,
		   successfully_matching_string => $successfully_matching_string,
		   before_match => $before_match,
		   after_match => $after_match,

		   #! skip the expect '-re' flag

		   expected => $read->[1],
		  };
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Alternatives;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # read

    if (defined $read)
    {
	# compose the alternatives regex

	if ($read->{alternatives})
	{
	    my $alternatives = $read->{alternatives};

	    $test_result->{expected} = '(' . (join '|', map { quotemeta } @$alternatives) . ')';

	    # read from the application

	    my $timeout = $self->get_timeout();

	    my ($matched_pattern_position,
		$error,
		$successfully_matching_string,
		$before_match,
		$after_match)
		= $executor->{expect_object}->expect($timeout, "-re", $test_result->{expected}, );

	    $test_result->{matched_pattern_position} = $matched_pattern_position;
	    $test_result->{error} = $error;
	    $test_result->{successfully_matching_string} = $successfully_matching_string;
	    $test_result->{before_match} = $before_match;
	    $test_result->{after_match} = $after_match;
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::File;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # read

    if (defined $read)
    {
	# if an application output file is expected

	if ($read->{application_output_file})
	{
	    # read it

	    my $application_output_file = $read->{application_output_file};

	    my $pwd = `pwd`;

	    chomp $pwd;

	    print $fd_output "*** Application output file: $application_output_file (in $pwd)\n";

	    # and compare it with an expected output file

	    my $expected_output_file = $read->{expected_output_file};

	    local $/;

	    my $application_output = `cat "$application_output_file"`;

	    my $expected_output;

	    if ($expected_output_file)
	    {
		print $fd_output "*** Expected output file: $expected_output_file\n";

		$expected_output = `cat "$expected_output_file"`;
	    }
	    elsif (defined $read->{expected_output})
	    {
		$expected_output = $read->{expected_output};
	    }

	    $test_result
		= {
		   expected => $expected_output,
		  };

	    if ($expected_output eq $application_output)
	    {
		$test_result->{before_match} = $application_output;
	    }
	    else
	    {
		$test_result->{before_match} = $application_output;

		$read = $expected_output;

		$test_result->{error} = 'expected_output does not match application_output';
	    }
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::CommandTest::Interactive::Shell;


our @ISA = ("Heterarch::Test::CommandTest::Interactive");


sub run
{
    my $self = shift;

    my $execution_context = shift;

    my $executor = shift;

    my $fd_output = shift;

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $command = $command_definition->{command};

    # expect this output

    my $test_result;

    # set read, wait and write strings

    my $read = $self->{read};

    # record time

    $self->before_run($execution_context, $fd_output);

    # do write processing

    $self->process_write($executor, $fd_output);

    # do wait processing

    $self->process_wait($execution_context, $fd_output);

    # do post processing

    $self->prepare_run($execution_context, $fd_output);

    # read

    if (defined $read)
    {
	# if there is a shell command given

	if ($read->{shell})
	{
	    # run it and capture its output

	    my $shell = $read->{shell};

	    my $expected = `$shell`;

	    # and compare its output with the output of the application

	    my $timeout = $self->get_timeout();

	    my ($matched_pattern_position,
		$error,
		$successfully_matching_string,
		$before_match,
		$after_match)
		= $executor->{expect_object}->expect($timeout, $expected, );

	    $test_result
		= {
		   matched_pattern_position => $matched_pattern_position,
		   error => $error,
		   successfully_matching_string => $successfully_matching_string,
		   before_match => $before_match,
		   after_match => $after_match,
		   expected => $expected,
		  };
	}
    }

    # try correcting

    $self->after_run($execution_context, $test_result);

    # return the final test result

    return $test_result;
}


package Heterarch::Test::Element;


package Heterarch::Test::ExecutionContext;


sub _execute
{
    my $executor_element = shift;

    my $description = shift;

    my $previous_result = shift;

    my $result = 'nothing executed';

    # either execute regular perl code

    if (ref $executor_element eq 'CODE')
    {
	$result = &$executor_element($previous_result);
    }

    # ... or instantiate the object that will do the preparation

    elsif (exists $executor_element->{class})
    {
	# instantiate the object

	my $class = $executor_element->{class};

	my $filename = $class . ".pm";

	$filename =~ s(::)(/)g;

	require $filename;

	my $executor_element_object = eval "$class->new()";

	# apply all the methods and collect the results

	$result = [];

	my $applicators = $executor_element->{applicators};

	foreach my $applicator (@$applicators)
	{
	    my $method = $applicator->{method};

	    my $arguments = $applicator->{arguments};

	    my $applicator_result = $executor_element_object->$method($arguments);

	    if (ref $applicator_result eq 'SCALAR')
	    {
		$result = \ "Error: $description failed ($$applicator_result)";

		last;
	    }

	    push @$result, $applicator_result;
	}
    }

    # or execute an array of system shell commands

    elsif (exists $executor_element->{system_commands})
    {
	my $system_commands = $executor_element->{system_commands};

	if (ref $system_commands eq 'ARRAY')
	{
	    foreach my $system_command (@$system_commands)
	    {
		system $system_command;

		if ($? ne 0)
		{
		    $result = \ "Error: $description failed ($system_command)";

		    last;
		}
	    }
	}
    }

    # return result

    return $result;
}


sub _get_current
{
    my $self = shift;

    my $path = $self->{path};

    my $current = $path->[$#$path];

    return $current;
}


sub _push_current
{
    my $self = shift;

    my $current = shift;

    my $path = $self->{path};

    push @$path, $current;
}


sub _pop_current
{
    my $self = shift;

    my $path = $self->{path};

    my $result = pop @$path;

    return $result;
}


sub end
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $description;

    my $name;

    if (defined $command_test)
    {
	$description = "*** Test: $command_test->{description}";

	$name = "";
    }
    elsif (defined $command_definition)
    {
	$description = "command $command_definition->{description}";

	$name = " ($command_definition->{command})";
    }
    else
    {
	$description = "module $module_definition->{description}";

	$name = " ($module_definition->{name})";
    }

    if (defined $command_test)
    {
    }
    else
    {
	Heterarch::Test::Reporting::report_message_end($fd_output, "End for tests of $description
Total of $global_test_report->{global}->{test_count} tests (encountered $global_error_count error(s) so far)");
    }

    $self->_pop_current();
}


sub get_command_definition
{
    my $self = shift;

    my $current = $self->_get_current();

    my $command_definition = $current->[1];

    return $command_definition;
}


sub get_command_test
{
    my $self = shift;

    my $current = $self->_get_current();

    my $command_test = $current->[2];

    return $command_test;
}


sub get_module_definition
{
    my $self = shift;

    my $current = $self->_get_current();

    my $module_definition = $current->[0];

    return $module_definition;
}


sub has_error_flag
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $error = $active_element->{error};

    my $description = $active_element->{description};

    if ($error)
    {
	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => $description,
		  error => "this test was tagged with the error flag",
		  module_name => $module_name,
		  subdescription => $error,
		 },
		);

	return 1;
    }
    else
    {
	return 0;
    }
}


sub is_disabled
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    my $active_element
	= (defined $command_test
	   ? $command_test
	   : (defined $command_definition
	      ? $command_definition
	      : $module_definition));

    my $disabled = $active_element->{disabled};

    if ($disabled)
    {
	my $description = $active_element->{description};

	if (not $option_show)
	{
	    Heterarch::Test::Reporting::report_message_info($fd_output, "Tests of $description are disabled ($disabled)
Total of $global_test_report->{global}->{test_count} tests (encountered $global_error_count error(s) so far)");

	    my $report_key
		= (defined $command_test
		   ? "command_tests"
		   : (defined $command_definition
		      ? "command_definitions"
		      : "modules"));

	    $global_test_report->{disabled}->{$report_key}->{$module_name}->{$description} = $disabled;
	}

	return 1;
    }
    else
    {
	return 0;
    }
}


sub preparation
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $fd_output = $self->{fd_output};

    my $module_name = $module_definition->{name};

    if ($command_definition)
    {
	if (exists $command_definition->{preparation}
	    and exists $command_definition->{harnessing})
	{
	    die "$0: command_definition ($command_definition->{description}) has both a preparation and harnessing clause\n";
	}
    }
    else
    {
	if (exists $module_definition->{preparation}
	    and exists $module_definition->{harnessing})
	{
	    die "$0: module_definition ($module_definition->{description}) has both a preparation and harnessing clause\n";
	}
    }

    my $definition = defined $command_definition ? $command_definition : $module_definition;

    # convert the old format preparation / reparation to the new format of harnessing

    if (not exists $definition->{harnessing})
    {
	if (exists $definition->{preparation})
	{
	    $definition->{harnessing}->{preparation} = $definition->{preparation};

	    delete $definition->{preparation};
	}

	if (exists $definition->{reparation})
	{
	    $definition->{harnessing}->{reparation} = $definition->{reparation};

	    delete $definition->{reparation};
	}
    }

    # process the harnessing preparation clause

    my $harnessing
	= ($command_definition
	   ? $command_definition->{harnessing}
	   : $module_definition->{harnessing});

    my $preparation = $harnessing->{preparation};

    my $preparation_result;

    # if there is a preparation clause

    if ((not $option_show)
	and $preparation)
    {
	# give diagnostics

	my $preparation_name
	    = ($command_definition
	       ? "command '$command_definition->{command}'"
	       : "module '$module_definition->{name}'");

	print $fd_output "*** Preparing $preparation_name ($preparation->{description})\n";

	# execute the preparation clause

	my $preparer = $preparation->{preparer};

	$preparation_result = _execute($preparer, 'preparation');

	# if the preparer returned an error string

	my $preparation_error;

	if (ref $preparation_result eq 'SCALAR')
	{
	    # obtain the error string

	    $preparation_error = $$preparation_result;
	}

	# process errors

	if ($preparation_error)
	{
	    my $module_name = $module_definition->{name};

	    my $subdescription
		= ($command_definition
		   ? $command_definition->{description}
		   : $module_definition->{description});

	    Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		     description => $preparation_name,
		     error => $preparation_error,
		     module_name => $module_name,
		     subdescription => $subdescription,
		 },
		);
	}
    }

    # return result

    return $preparation_result;
}


sub new
{
    my $package = shift;

    my $fd_output = shift;

    my $options = shift || {};

    my $self
	= {
	   %$options,
	   path => [],
	   fd_output => $fd_output,
	  };

    bless $self, $package;

    return $self;
}


sub reparation
{
    my $self = shift;

    my $command_definition = shift;

    my $preparation_result = shift;

    my $fd_output = $self->{fd_output};

    my $module_definition = $self->get_module_definition();

    my $module_name = $module_definition->{name};

    # process the harnessing reparation clause

    my $harnessing
	= ($command_definition
	   ? $command_definition->{harnessing}
	   : $module_definition->{harnessing});

    my $reparation = $harnessing->{reparation};

    my $reparation_name
        = ($command_definition
	    ? ($command_definition->{command}
		? "command '$command_definition->{command}'"
		: "module '$module_definition->{name}'")
	    : ($command_definition->{recycle}
		? "these tests use the previous running command ($command_definition->{recycle})"
		: "*** Error: this command definition is incomplete (no command and no recycle clause)")
	);

    my $reparation_error;

    # if there is a reparation clause

    if ((not $option_show)
	and $reparation)
    {
	# give diagnostics

	print $fd_output "*** Reparing $reparation_name ($reparation->{description})\n";

	# execute the reparation clause

	my $reparer = $reparation->{reparer};

	$reparation_error = _execute($reparer, 'reparation', $preparation_result);

	# process errors

	if ($reparation_error)
	{
	    my $module_name = $module_definition->{name};

	    my $subdescription
		= ($command_definition
		   ? $command_definition->{description}
		   : $module_definition->{description});

	    Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		     description => $reparation_name,
		     error => $reparation_error,
		     module_name => $module_name,
		     subdescription => $subdescription,
		 },
		);
	}
    }

    return $reparation_error;
}


sub start
{
    my $self = shift;

    my $module_definition = shift;

    my $command_definition = shift;

    my $command_test = shift;

    my $started;

    # if this test is disabled

    if ($self->is_disabled($module_definition, $command_definition, $command_test))
    {
	# return to skip it

	return $started;
    }

    # if this test has been flagged with an error

    if ($self->has_error_flag($module_definition, $command_definition, $command_test))
    {
	# return to skip it

	return $started;
    }

    # update the path of execution

    $self->_push_current( [ $module_definition, $command_definition, $command_test, ] );

    my $comment;

    my $description;

    my $name;

    if (defined $command_test)
    {
	$comment = $command_test->{comment};

	$description = "*** Test: $command_test->{description}";

	$name = "";
    }
    elsif (defined $command_definition)
    {
	$comment = $command_definition->{comment};

	$description = "command $command_definition->{description}";

	$name = " ($command_definition->{command})";
    }
    else
    {
	$comment = $module_definition->{comment};

	$description = "module $module_definition->{description}";

	$name = " ($module_definition->{name})";
    }

    # give diagnostics

    my $fd_output = $self->{fd_output};

    if (not defined $command_test)
    {
	Heterarch::Test::Reporting::report_message_start($fd_output, "Running tests of $description$name");

	if ($comment)
	{
	    Heterarch::Test::Reporting::report_message($fd_output, "*** Comment: $comment");
	}
    }
    else
    {
	Heterarch::Test::Reporting::report_message($fd_output, "$description");

	if ($comment)
	{
	    Heterarch::Test::Reporting::report_message($fd_output, "*** Comment: $comment");
	}
    }

    $started = 'yes';

    return $started;
}


sub terminate
{
    my $self = shift;

    my $fd_output = $self->{fd_output};

    my $path = $self->{path};

    if (scalar @$path)
    {
	my $module_definition = $self->get_module_definition();

	my $description = "module $module_definition->{description}";

	my $module_name = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
	    (
	     $fd_output,
	     {
	      description => "execution context invalid",
	      error => "left over elements in the execution context after it was terminated",
	      module_name => $module_name,
	     },
	    );
    }
}


package Heterarch::Test::Executor;


sub new
{
    my $package = shift;

    my $execution_context = shift;

    my $fd_output = $execution_context->{fd_output};

    my $options = shift || {};

    my $self
	= {
	   %$options,
	   execution_context => $execution_context,
	   fd_output => $fd_output,
	  };

    bless $self, $package;

    return $self;
}


sub run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $fd_output = $self->{fd_output};

    return $command_test->run($execution_context, $self, $fd_output);
}


# instantiate the tester:
#
# 1. an object given its class.
# 2. a piece of perl code that is run.
# 3. an interactive system shell command.
#

sub start
{
    my $self = shift;

    my $execution_context = $self->{execution_context};

    my $module_definition = $execution_context->get_module_definition();

    my $command_definition = $execution_context->get_command_definition();

    my $fd_output = $self->{fd_output};

    # we have to either instantiate an object that produces output ...

    if ($command_definition->{class})
    {
	# instantiate the object

	my $class = $command_definition->{class};

	my $filename = $class . ".pm";

	$filename =~ s(::)(/)g;

	require $filename;

	$self->{command_object} = eval "$class->new()";
    }

    # ... or run perl code that produces output

    elsif (ref $command_definition->{command} eq 'CODE')
    {
	# code is already instantiated, nothing to do here
    }

    # ... or run a command that produces output

    else
    {
	# start the command and connect with its I/O channels

	#! this is similar to having a class name 'Expect' and calling Expect->new()
	#! but with optimization to prevent spawning new commands unnecessarily

	my ($exp, $test_startup) = $command_definition->spawn_new($fd_output);

	$self->{expect_object} = $exp;

	$self->{test_startup} = $test_startup;
    }
}


package Heterarch::Test::Library;


sub construct
{
    # find the test specifications

    my $test_modules
	= [
	   map
	   {
	       chomp; $_;
	   }
	   sort
	   `find $global_config->{tests_directory} -name "*.t"`,
	  ];

    return $test_modules;
}


sub expand
{
    my $fd_output = shift;;

    my $library = shift;

    my $result = [];

    # parse all modules

    foreach my $test_module (@$library)
    {
	if ($test_module !~ /$option_regex_selector/i)
	{
	    next;
	}

	my $module_definition = readfile($fd_output, $test_module);

	if ($module_definition)
	{
	    push @$result, $module_definition;
	}
    }

    if ($option_flattenout)
    {
	# sort modules

	#t first need to transform: select command_definitions, flatten
	#t out, keep the module names (for referencing errors).

	my $transformator
	    = Data::Transformator->new
		(
		 apply_identity_transformation => 0,
		 name => 'test-module-selector',
		 contents => $result,
		 separator => '`',
		 array_filter =>
		 sub
		 {
		     my ($context, $component) = @_;

		     # never filter for the first two component in the path

		     my $depth = $context->{array};
		     $depth = $#$depth;

		     if ($depth < 2)
		     {
			 return 1;
		     }

		     # extract the data: command definitions with test commands

		     $context->{path} =~ m|^[^/]*/([^/]*)/([^/]*)|;

		     my $content = Data::Transformator::_context_get_current_content($context);

		     # push it onto the result

		     my $result = Data::Transformator::_context_get_main_result($context);

		     if (!$result->{content})
		     {
			 $result->{content} = [];
		     }

		     push @{$result->{content}}, $content;

		     # add the module name

		     my $module_name = $context->{array}->[1]->{content}->{name};

		     $content->{module_name} = $module_name;

		     # add the module description

		     my $module_description = $context->{array}->[1]->{content}->{description};

		     $content->{module_description} = $module_description;

		     # result is known, everything gets filtered

		     0;
		 },
		);

	#t for an empty array as content, the transformator returns an
	#t undef, this is a bug that still needs fixing.

	my $tests = $transformator->transform() || [];

	# sort the flattened test definitions

	$tests
	    = [
	       sort
	       {
		   my $module1 = $a;
		   my $module2 = $b;

		   my $command1 = $module1->{command};
		   my $command2 = $module2->{command};

		   my $command1_arguments = $module1->{arguments} || [];
		   my $command2_arguments = $module2->{arguments} || [];

		   my $command1_string = join ' ', $command1, @$command1_arguments;
		   my $command2_string = join ' ', $command2, @$command2_arguments;

		   my $comparison = $command1_string cmp $command2_string;

		   if ($module1->{tester_head})
		   {
		       $comparison = -1;
		   }
		   elsif ($module2->{tester_head})
		   {
		       $comparison = 1;
		   }

		   $comparison;
	       }
	       @$tests,
	      ];

	# transform back to the regular test module format by putting
	# every command definition in its own module

	$tests
	    = [
	       map
	       {
		   my $command_definition = $_;

		   (
		    {
		     command_definitions => [
					     $command_definition,
					    ],
		     description => $command_definition->{module_description},
		     name => $command_definition->{module_name},
		    }
		   );
	       }
	       @$tests,
	      ];

	# set result

	$result = $tests;
    }

    # return result

    return $result;
}


sub is_json
{
    my $filename = shift;

    my $result;

    use IO::File;

    my $fh = IO::File->new();

    if ($fh->open("< $filename"))
    {
	my $first_line = <$fh>;

	$first_line =~ s/(\s)*//g;

	if ($first_line =~ m'^\{')
	{
	    $result = 'is_json';
	}

	$fh->close;
    }

    return $result;
}


sub is_yaml
{
    my $filename = shift;

    my $result;

    use IO::File;

    my $fh = IO::File->new();

    if ($fh->open("< $filename"))
    {
	my $first_line = <$fh>;

	$first_line =~ s/(\s)*//g;

	if ($first_line eq '---')
	{
	    $result = 'is_yaml';
	}

	$fh->close;
    }

    return $result;
}


sub randomize_order
{
    my $test_modules = shift;

    my $random_seed = shift;

    # by default the randomizer will choose a random_seed

    if (not defined $random_seed)
    {
	$random_seed = time() ^ $$ ^ unpack "%L*", `ps axww | gzip`;
    }

    # set the random_seed

    srand($random_seed);

    # and shuffle the modules

    require List::Util;

    return ( [ List::Util::shuffle(@$test_modules), ], $random_seed );
}


sub readfile
{
    my $fd_output = shift;

    my $pathname = shift;

    my $result;

    if (is_yaml($pathname))
    {
	use YAML;

	$result = YAML::LoadFile($pathname);

	if ($@)
	{
	    report_error_add
	    (
	     $fd_output,
	     {
	      description => $@,
	      error => $@,
	      module_name => $pathname,
	     },
	    );
	}
    }
    elsif (is_json($pathname))
    {

	local $/; # enable 'slurp' mode

	my $file = IO::File->new("<$pathname");

	my $json_text = <$file>;

	$file->close();

	use JSON;

	my $json = JSON->new();

	#! allow code refs, they are converted to nulls

	$json->allow_unknown(1);

	$result = $json->decode($json_text);

	if ($@)
	{
	    report_error_add
	    (
	     $fd_output,
	     {
	      description => $@,
	      error => $@,
	      module_name => $pathname,
	     },
	    );
	}
    }
    else
    {
	$result = do $pathname;

	if ($@)
	{
	    report_error_add
	    (
	     $fd_output,
	     {
	      description => $@,
	      error => $@,
	      module_name => $pathname,
	     },
	    );
	}
    }

    $pathname =~ m((.*)/(.*));

    my $filename = $2;

    if ($option_dump_json)
    {
	use JSON;

	my $json = JSON->new();

	#! allow code refs, they are converted to nulls

	$json->allow_unknown(1);

	my $file = IO::File->new(">/tmp/$filename.js");

	print $file $json->encode($result);

	$file->close();
    }

    if ($option_dump_perl)
    {
	use Data::Dumper;

	my $file = IO::File->new(">/tmp/$filename.pl");

	print $file Dumper($result);

	$file->close();
    }

    if ($option_dump_yaml)
    {
	YAML::DumpFile("/tmp/$filename.yml", $result);
    }

    # check if the name of the test and the pathname match

    if ($option_check_test_names)
    {
	if ($pathname ne "$global_config->{tests_directory}/$result->{name}")
	{
	    Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		     description => "the pathname ($pathname) and the test name ($result->{name}) are different",
		     error => "the pathname ($pathname) and the test name ($result->{name}) are different",
		     module_name => $pathname,
		 },
		);
	}
    }

    return $result;
}


package Heterarch::Test::Module;


our @ISA = ("Heterarch::Test::Element");


# could also use Array::Util, but it is not always installed

sub array_union_intersection_difference
{
    my $array1 = shift;

    my $array2 = shift;

    my (@union, @intersection, @difference);

    my %count = ();

    foreach my $element (@$array1, @$array2)
    {
	$count{$element}++
    }

    foreach my $element (keys %count)
    {
	push @union, $element;

	push @{ $count{$element} > 1
		    ? \@intersection
		    : \@difference },
		    $element;
    }

    return ( \@union, \@intersection, \@difference );
}


sub check_description
{
    my $module_definition = shift;

    my $fd_output = shift;

    my $module_name = $module_definition->{name};

    if (!defined $module_definition->{description})
    {
	$module_definition->{description} = $module_definition->{name};

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => 'no module description',
		  error => 'no module description',
		  module_name => $module_name,
		 },
		);
    }

    return $module_definition->{description};
}


sub check_name
{
    my $module_definition = shift;

    my $fd_output = shift;

    if (!defined $module_definition->{name})
    {
	$module_definition->{name} = 'unnamed';

	Heterarch::Test::Reporting::report_error_add
		(
		 $fd_output,
		 {
		  description => 'unnamed module',
		  error => 'unnamed module',
		  module_name => 'unnamed module',
		 },
		);
    }

    return $module_definition->{name};
}


sub is_selected_by_tag
{
    my $module_definition = shift;

    my $fd_output = shift;

    my $module_name = $module_definition->{name};

    if (not scalar @$option_tags)
    {
	return ":all";
    }

    my $module_definition_tags = $module_definition->{tags};

    # use Array::Util qw(intersect);

    my ( $union, $intersection, $difference ) = array_union_intersection_difference($module_definition_tags, $option_tags);

    if (scalar @$intersection)
    {
	return $intersection;
    }
    else
    {
	if (not $option_show)
	{
	    Heterarch::Test::Reporting::report_message_info($fd_output, "Module $module_definition->{description} is not selected by tag (" . (join ", ", @$option_tags ) . " are selected tags).
Total of $global_test_report->{global}->{test_count} tests (encountered $global_error_count error(s) so far)");
	}

	$global_test_report->{not_selected_by_tag}->{modules}->{$module_name} = 'not_selected_by_tag';

	return undef;
    }
}


package Heterarch::Test::Output::Formatter;


our @ISA = ("Heterarch::Test::Executor");


sub run
{
    die "$0: *** Error: this output formatter is not fully implemented.";

    return undef;
}


package Heterarch::Test::Output::Formatter::HTMLTable;


our @ISA = ("Heterarch::Test::Output::Formatter");


sub start
{
    my $self = shift;

    my $execution_context = $self->{execution_context};

    my $module_definition = $execution_context->get_module_definition();

    my $command_definition = $execution_context->get_command_definition();

    my $fd_output = $self->{fd_output};

    # we have to either instantiate an object that produces output ...

    if ($command_definition->{class})
    {
	# instantiate the object

	my $class = $command_definition->{class};

	my $filename = $class . ".pm";

	$filename =~ s(::)(/)g;

	# require $filename;

	# $self->{command_object} = eval "$class->new()";
    }

    # ... or run perl code that produces output

    elsif (ref $command_definition->{command} eq 'CODE')
    {
	# code is already instantiated, nothing to do here
    }

    # ... or run a command that produces output

    else
    {
	# start the command and connect with its I/O channels

	# my ($exp, $test_startup) = $command_definition->spawn_new($fd_output);

	my $command = $command_definition->{command};

	# remember to spawn a new command

	my $spawn_new = not $command_definition->{recycle};

	my $arguments = $command_definition->{arguments};

	# if the command can be executed

	if (defined $command)
	{
	    if ($spawn_new)
	    {
	    }
	    else
	    {
		# print $fd_output "*** Recycling $command " . (join ' ', map { "'$_'" } @$arguments) . "\n";
	    }
	}
    }
}


package Heterarch::Test::Output::Formatter::YAML::Summary;


our @ISA = ("Heterarch::Test::Output::Formatter");


# create an output entry for the current command definition

sub start
{
    my $self = shift;

    # get the execution context

    my $execution_context = $self->{execution_context};

    # create an output entry for the module

    #t we could add a counter here to keep the order of execution in the final yaml output

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    if (not $global_test_report->{selected}->{$module_name})
    {
	$global_test_report->{selected}->{$module_name} = [];
    }

    # create an output entry for the current command definition

    my $selected_module = $global_test_report->{selected}->{$module_name};

    my $command_definition = $execution_context->get_command_definition();

    push @$selected_module, { description => $command_definition->{description}, tests => [], };
}


# add the current test description to the summary

sub run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

    my $module_name = $module_definition->{name};

    # get the current module summary

    my $selected_module = $global_test_report->{selected}->{$module_name};

    # get the current test summary

    my $selected_command_definitions = $selected_module->[$#$selected_module]->{tests};

    # add the current test description to the summary

    push @$selected_command_definitions, $command_test->{description};

    # always succeeds

    my $test_result
	= {
	   after_match => "",
	   before_match => "",
	   error => "",
	   expected => "",
	   matched_pattern_position => "",
	   successfully_matching_string => "",
	  };

    return $test_result;
}


package Heterarch::Test::Output::Definitions;


our @ISA = ("Heterarch::Test::Executor");


package Heterarch::Test::Output::List;


# inherit from the yaml summary to automate text context tracking through its start sub

our @ISA = ("Heterarch::Test::Output::Formatter::YAML::Summary");


sub run
{
    my $self = shift;

    my $command_test = shift;

    my $execution_context = $self->{execution_context};

    my $command_definition = $execution_context->get_command_definition();

    my $module_definition = $execution_context->get_module_definition();

}


package Heterarch::Test::Reporting;


sub report_error_add
{
    my $fd_output = shift;

    my $arguments = shift;

    my $description = $arguments->{description};
    my $error = $arguments->{error};
    my $expected = $arguments->{expected};
    my $message = $arguments->{message};
    my $module_name = $arguments->{module_name};
    my $seen = $arguments->{seen};
    my $subdescription = $arguments->{subdescription};

    my $package_name = $global_test_report->{description}->{package}->{name};

    $global_error_count++;

    print $fd_output "*** Error $global_error_count: $error ($description, package $package_name, $module_name, error_count $global_error_count)\n";

    # fill in the error report

    $global_test_report->{global}->{error_count} = $global_error_count;

    if ($subdescription)
    {
	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{$subdescription}->{description} = $description;
    }
    else
    {
	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{description} = $description;
    }

    $global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{error} = $error;

    if (defined $message)
    {
	#! subdescription can be undefined here, in which case
	#! $message is undefined too.  Both can be defined when
	#! running in verbose mode seems, allows to track regex
	#! problems ... I think.

	$global_test_report->{errors}->{modules}->{$module_name}->{$global_error_count}->{$subdescription}->{report} = $message;
    }

    if (defined $expected
	and defined $seen)
    {
	my $processed_expected = [ split "\n", $expected, ];

	$processed_expected = join "\n*** Error $global_error_count: expected: ", "", @$processed_expected, "\n";

	print $fd_output $processed_expected;

	my $processed_seen = [ split "\n", $seen, ];

	$processed_seen = join "\n*** Error $global_error_count: seen: ", "", @$processed_seen, "\n";

	print $fd_output $processed_seen;

	use IO::File;

	my $expected_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.expected";

	my $expected_file = IO::File->new(">$expected_filename");

	if ($expected_file)
	{
	    print $expected_file $expected;

	    $expected_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $expected_filename for writing\n";
	}

	my $seen_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.seen";

	my $seen_file = IO::File->new(">$seen_filename");

	if ($seen_filename)
	{
	    print $seen_file $seen;

	    $seen_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $seen_filename for writing\n";
	}

	my $diff = `diff "$expected_filename" "$seen_filename"`;

	my $diff_filename = "/tmp/text_$global_config->{package}->{name}_$global_error_count.diff";

	my $diff_file = IO::File->new(">$diff_filename");

	if ($diff_file)
	{
	    print $diff_file $diff;

	    $diff_file->close();
	}
	else
	{
	    print $fd_output "*** Warning: cannot open $diff_filename for writing\n";
	}

	my $processed_diff = [ split "\n", $diff, ];

	$processed_diff = join "\n*** Error $global_error_count: diff: ", "", @$processed_diff, "\n";

	print $fd_output $processed_diff;
    }

}


my $rulers_not_used
    = {
       end => { bottom => 2, top => 1, },
       info => { bottom => 1, top => 1, },
       start => { bottom => 1, top => 2, },
      };

sub report_message
{
    my $fd_output = shift;

    my $message = shift;

    if (!$option_show)
    {
	print $fd_output "$message\n";
    }
}


sub report_message_end
{
    my $fd_output = shift;

    my $message = shift;

    return report_message_with_rulers($fd_output, 1, 2, $message);
}


sub report_message_info
{
    my $fd_output = shift;

    my $message = shift;

    return report_message_with_rulers($fd_output, 1, 1, $message);
}


sub report_message_start
{
    my $fd_output = shift;

    my $message = shift;

    return report_message_with_rulers($fd_output, 2, 1, $message);
}


sub report_message_with_rulers
{
    my $fd_output = shift;

    my $top_ruler = shift;

    my $bottom_ruler = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    if (!$option_show)
    {
	print $fd_output "\n";
	print $fd_output "$line\n" for 0 .. $top_ruler;
	print $fd_output "\n";
	print $fd_output "$message\n\n";
	print $fd_output "$line\n" for 0 .. $bottom_ruler;
	print $fd_output "\n";
    }
}


package main;


main();


